[
  {
    "_id": "60d6bb63a214c8473c32ae29",
    "categoryId": "643141b968949c11e8ca911b",
    "commentNumber": "0",
    "createDate": "1682324281058",
    "description": "Markdown 语法和 MWeb 写作使⽤说明",
    "htmlContent": "<p><a href=\"https://www.yuque.com/attachments/yuque/0/2023/pdf/34617067/1677678996543-15d803f9-2ae0-4941-8c8c-628ebf88deef.pdf\">Markdown 语法和 MWeb 写作使用说明.pdf</a></p><p>Markdown <strong>的设计哲学</strong></p><blockquote><p>Markdown 的⽬標是實現「易讀易寫」。</p><p>不過最需要強調的便是它的可讀性。⼀份使⽤ Markdown 格式撰寫的⽂件應該可以直接以純</p><p>⽂字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。</p><p>Markdown 的語法有個主要的⽬的：⽤來作為⼀種網路內容的寫作⽤語⾔。</p></blockquote><p><strong>本⽂约定</strong></p><p>如果有写 <code data-backticks=\"1\">效果如下：</code> ， 在 MWeb 编辑状态下只有⽤ <code data-backticks=\"1\">CMD + 4</code> 或 <code data-backticks=\"1\">CMD + R</code> 预览才可以看效果。</p><h2 id=\"h1标题\">1.标题</h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\"># 第⼀级标题 `&lt;h1&gt;` \n## 第⼆级标题 `&lt;h2&gt;` \n###### 第六级标题 `&lt;h6&gt;`</code></pre></div><p>效果如下：</p><p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/34617067/1677676438458-6fe2fcd8-9fa6-4c09-a4d0-80b8834b9caa.png#averageHue=%23eaeaea&amp;clientId=u7d7b771a-8a9a-4&amp;from=paste&amp;height=376&amp;id=udb81deb8&amp;name=image.png&amp;originHeight=376&amp;originWidth=508&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33614&amp;status=done&amp;style=none&amp;taskId=uc588465d-6389-4d80-96b0-2ebed840608&amp;title=&amp;width=508\" alt=\"image.png\" contenteditable=\"false\"><br></p><h2 id=\"h2强调\">2.强调</h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">*这些⽂字会⽣成`&lt;em&gt;`*\n_这些⽂字会⽣成`&lt;u&gt;`_\n**这些⽂字会⽣成`&lt;strong&gt;`**\n__这些⽂字会⽣成`&lt;strong&gt;`__</code></pre></div><p>在 MWeb 中的快捷键为： <code data-backticks=\"1\">CMD + U </code>、 <code data-backticks=\"1\">CMD + I </code>、 <code data-backticks=\"1\">CMD + B</code></p><p>效果如下：</p><p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/34617067/1677676471880-35de2acd-776a-49a7-80df-44c0d95f1b78.png#averageHue=%23e9e8e6&amp;clientId=u7d7b771a-8a9a-4&amp;from=paste&amp;height=239&amp;id=u1c1b2e62&amp;name=image.png&amp;originHeight=239&amp;originWidth=401&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=45853&amp;status=done&amp;style=none&amp;taskId=u757024fa-b437-4a66-a33e-5ce29bb6818&amp;title=&amp;width=401\" alt=\"image.png\" contenteditable=\"false\"><br></p><h2 id=\"h3换行\">3.换行</h2><p>四个及以上空格加回⻋。</p><p>如果不想打这么多空格，只要回⻋就为换⾏，请勾选： <code data-backticks=\"1\">Preferences</code> - <code data-backticks=\"1\">Themes</code> - <code data-backticks=\"1\">Translate</code></p><p><code data-backticks=\"1\">newlines to &lt;br&gt; tags</code></p><h2 id=\"h4列表\">4.列表</h2><h3 id=\"h无序列表\">无序列表</h3><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">* 项⽬⼀ ⽆序列表 `* + 空格键`\n* 项⽬⼆\n\t* 项⽬⼆的⼦项⽬⼀ ⽆序列表 `TAB + * + 空格键`\n\t* 项⽬⼆的⼦项⽬⼆</code></pre></div><p>在 MWeb 中的快捷键为：<code data-backticks=\"1\"> Option + U</code></p><p>效果如下：</p><ul><li><p>项⽬⼀ ⽆序列表 <code data-backticks=\"1\">* + 空格键</code></p></li><li><p>项⽬⼆</p><ul><li><p>项⽬⼆的⼦项⽬⼀ ⽆序列表 <code data-backticks=\"1\">TAB + * + 空格键</code></p></li><li><p>项⽬⼆的⼦项⽬⼆</p></li></ul></li></ul><h3 id=\"h有序列表\">有序列表</h3><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">1. 项⽬⼀ 有序列表 `数字 + . + 空格键`\n2. 项⽬⼆\n3. 项⽬三\n\t1. 项⽬三的⼦项⽬⼀ 有序列表 `TAB + 数字 + . + 空格键`\n\t2. 项⽬三的⼦项⽬⼆</code></pre></div><p>效果如下：</p><ol><li><p>项⽬⼀ 有序列表 <code data-backticks=\"1\">数字 + . + 空格键</code></p></li><li><p>项⽬⼆</p></li><li><p>项⽬三</p><ol><li><p>项⽬三的⼦项⽬⼀ 有序列表 <code data-backticks=\"1\">TAB + 数字 + . + 空格键</code></p></li><li><p>项⽬三的⼦项⽬⼆</p></li></ol></li></ol><h3 id=\"h任务列表task-lists\"><strong>任务列表（Task lists</strong>）</h3><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">- [ ] 任务⼀ 未做任务 `- + 空格 + [ ]`\n- [x] 任务⼆ 已做任务 `- + 空格 + [x]`</code></pre></div><p>效果如下：</p><ul><li class=\"task-list-item\" data-task=\"true\"><p>任务⼀ 未做任务 <code data-backticks=\"1\">- + 空格 + [ ]</code></p></li><li class=\"task-list-item checked\" data-task=\"true\" data-task-checked=\"true\"><p>任务⼆ 已做任务 <code data-backticks=\"1\">- + 空格 + [x]</code></p></li></ul><h2 id=\"h5图片\">5.图片</h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)\n格式: ![Alt Text](url)</code></pre></div><p><code data-backticks=\"1\">Control + Shift + I </code>可插⼊Markdown语法。</p><p>如果是 MWeb 的⽂档库中的⽂档，还可以⽤拖放图⽚、 <code data-backticks=\"1\">CMD + V</code> 粘贴、 <code data-backticks=\"1\">CMD + Option + I</code> 导⼊</p><p>这三种⽅式来增加图⽚。</p><p>效果如下：</p><p><img src=\"http://zh.mweb.im/asset/img/set-up-git.gif#id=yIqs1&amp;originHeight=250&amp;originWidth=310&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" contenteditable=\"false\"><br></p><p>格式: <img src=\"url#id=IIC3G&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=\" contenteditable=\"false\"><br></p><p>MWeb 引⼊的特别的语法来设置图⽚宽度，⽅法是在图⽚描述后加 <code data-backticks=\"1\">-w + 图⽚宽度</code> 即可，⽐如说</p><p>要设置上⾯的图⽚的宽度为 140，语法如下：</p><p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/34617067/1677678727965-2723c12e-d4d6-4ecf-b6df-226455edd2cd.png#averageHue=%23dad5d4&amp;clientId=u7d7b771a-8a9a-4&amp;from=paste&amp;height=135&amp;id=uc8c4e377&amp;name=image.png&amp;originHeight=135&amp;originWidth=127&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9321&amp;status=done&amp;style=none&amp;taskId=uaf152fd0-a046-443a-806a-e37aca834ef&amp;title=&amp;width=127\" alt=\"image.png\" contenteditable=\"false\"><br></p><h2 id=\"h6链接\">6.链接</h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">email &lt;example@example.com&gt;\n[GitHub](http://github.com)\n⾃动⽣成连接 &lt;http://www.github.com/&gt;</code></pre></div><p><code data-backticks=\"1\">Control + Shift + L</code> 可插⼊Markdown语法。</p><p>如果是 MWeb 的⽂档库中的⽂档，拖放或 <code data-backticks=\"1\">CMD + Option + I</code> 导⼊⾮图⽚时，会⽣成连接。</p><p>效果如下：</p><p>email <a href=\"mailto:example@example.com\">example@example.com</a></p><p><a href=\"http://github.com\">GitHub</a></p><p>⾃动⽣成连接 <a href=\"http://www.github.com/\">http://www.github.com/</a></p><h2 id=\"h7区块引⽤\">7.<strong>区块引⽤</strong></h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">某某说:\n&gt; 第⼀⾏引⽤\n&gt; 第⼆⾏费⽤⽂字</code></pre></div><p><code data-backticks=\"1\">CMD + Shift + B</code> 可插⼊Markdown语法。</p><p>效果如下：</p><p>某某说:</p><blockquote><p>第⼀⾏引⽤</p><p>第⼆⾏费⽤⽂字</p></blockquote><h2 id=\"h8⾏内代码\">8.<strong>⾏内代码</strong></h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">像这样即可：`&lt;addr&gt;` `code`</code></pre></div><p><code data-backticks=\"1\">CMD + K</code> 可插⼊Markdown语法。</p><p>效果如下：</p><p>像这样即可：<code data-backticks=\"1\">&lt;addr&gt;</code> <code data-backticks=\"1\">code</code></p><h2 id=\"h9多⾏或者⼀段代码\">9.<strong>多⾏或者⼀段代码</strong></h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">```js\nfunction fancyAlert(arg) {\n if(arg) {\n $.facebox({div:'#foo'})\n }\n}</code></pre></div><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>`CMD + Shift + K `可插⼊Markdown语法。\n效果如下：\n```javascript\nfunction fancyAlert(arg) {\n if(arg) {\n $.facebox({div:'#foo'})\n }\n}</code></pre></div><h2 id=\"h10顺序图或流程图\">10.<strong>顺序图或流程图</strong></h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">顺序图\n```sequence\n张三-&gt;李四: 嘿，⼩四⼉, 写博客了没?\nNote right of 李四: 李四愣了⼀下，说：\n李四--&gt;张三: 忙得吐⾎，哪有时间写。</code></pre></div><p>流程图</p><div data-language=\"flow\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"flow\">st=&gt;start: 开始\ne=&gt;end: 结束\nop=&gt;operation: 我的操作\ncond=&gt;condition: 确认？\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op</code></pre></div><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>效果如下（`Preferences `- `Themes `- `Enable sequence &amp; flow chart` 才会看到效果）：\n顺序图：\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34617067/1677677704703-314b9ec5-d319-44ab-b8a7-25893b842125.png#averageHue=%23f4f3f3&amp;clientId=u7d7b771a-8a9a-4&amp;from=paste&amp;height=254&amp;id=u5adf0197&amp;name=image.png&amp;originHeight=254&amp;originWidth=430&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17215&amp;status=done&amp;style=none&amp;taskId=uc116e02c-6543-489c-9e88-d689b58ac16&amp;title=&amp;width=430)\n流程图：\n![](https://cdn.nlark.com/yuque/__flowchart/e3d61f62af2e990e0b774348a98e9a38.svg#lake_card_v2=eyJ0eXBlIjoiZmxvd2NoYXJ0IiwiY29kZSI6InN0PT5zdGFydDog5byA5aeLXG5lPT5lbmQ6IOe7k-adn1xub3A9Pm9wZXJhdGlvbjog5oiR55qE5pON5L2cXG5jb25kPT5jb25kaXRpb246IOehruiupO-8n1xuc3QtPm9wLT5jb25kXG5jb25kKHllcyktPmVcbmNvbmQobm8pLT5vcCIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX2Zsb3djaGFydC9lM2Q2MWY2MmFmMmU5OTBlMGI3NzQzNDhhOThlOWEzOC5zdmciLCJpZCI6ImEwMzk1NzJkIiwiY2FyZCI6ImRpYWdyYW0ifQ==)\n## 11.**表格**\n```markdown\n|第⼀格表头 | 第⼆格表头|\n|--------- | -------------|\n|内容单元格 第⼀列第⼀格 | 内容单元格第⼆列第⼀格|\n|内容单元格 第⼀列第⼆格 多加⽂字 | 内容单元格第⼆列第⼆格|</code></pre></div><p>效果如下：</p><table><thead><tr><th><p>第⼀格表头</p></th><th><p>第⼆格表头</p></th></tr></thead><tbody><tr><td><p>内容单元格 第⼀列第⼀格</p></td><td><p>内容单元格第⼆列第⼀格</p></td></tr><tr><td><p>内容单元格 第⼀列第⼆格 多加⽂字</p></td><td><p>内容单元格第⼆列第⼆格</p></td></tr></tbody></table><h2 id=\"h12删除线\">12.<strong>删除线</strong></h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">加删除线像这样⽤： ~~删除这些~~</code></pre></div><p>效果如下：</p><p>加删除线像这样⽤： <del>删除这些</del></p><h2 id=\"h13分隔线\">13.<strong>分隔线</strong></h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">***\n*****\n- - -</code></pre></div><p>效果如下：</p><div contenteditable=\"false\"><hr></div><div contenteditable=\"false\"><hr></div><div contenteditable=\"false\"><hr></div><h2 id=\"h14mathjax\">14.MathJax</h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">块级公式：\n$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n\\\\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =\n1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}\n{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\\\]\n⾏内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$</code></pre></div><p>效果如下（<code data-backticks=\"1\">Preferences </code>- <code data-backticks=\"1\">Themes </code>- <code data-backticks=\"1\">Enable MathJax</code> 才会看到效果）：</p><p>块级公式：</p><p>$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$</p><p>\\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =</p><p>1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}</p><p>{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\]</p><p>⾏内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$</p><h2 id=\"h15脚注footnote\">15.<strong>脚注（Footnote</strong>）</h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">这是⼀个脚注：[^sample_footnote]</code></pre></div><p>效果如下：</p><p>这是⼀个脚注：[^sample_footnote]</p><h2 id=\"h16注释和阅读更多\">16.<strong>注释和阅读更多</strong></h2><p><code data-backticks=\"1\">Actions</code>-&gt;<code data-backticks=\"1\">Insert Read More Comment</code> 或者 <code data-backticks=\"1\">Command + .</code></p><p>**注 **阅读更多的功能只⽤在⽣成⽹站或博客时，插⼊时注意要后空⼀⾏。</p><h2 id=\"h17toc\">17.TOC</h2><div data-language=\"markdown\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"markdown\">[TOC]</code></pre></div><p>效果如下：</p><p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/34617067/1677678936987-47babfe0-6ca5-4243-b700-19907323f5af.png#averageHue=%23fefefe&amp;clientId=u7d7b771a-8a9a-4&amp;from=paste&amp;height=797&amp;id=u4c58ab09&amp;name=image.png&amp;originHeight=797&amp;originWidth=326&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=60949&amp;status=done&amp;style=none&amp;taskId=u43a7ffb5-2aa1-4386-83c9-7d2e6a6383d&amp;title=&amp;width=326\" alt=\"image.png\" contenteditable=\"false\"><br></p>",
    "scanNumber": "132",
    "thumb": "/static/upload/2023-4-24-16-18-0-152-3305b.jpg",
    "title": "Markdown 语法和 MWeb 写作使⽤说明",
    "toc": "[ { \"name\" : \"1.标题\", \"anchor\" : \"1标题\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"2.强调\", \"anchor\" : \"2强调\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"3.换行\", \"anchor\" : \"3换行\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"4.列表\", \"anchor\" : \"4列表\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ { \"name\" : \"无序列表\", \"anchor\" : \"无序列表\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"有序列表\", \"anchor\" : \"有序列表\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"**任务列表（Task lists**）\", \"anchor\" : \"任务列表task-lists\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] } ] }, { \"name\" : \"5.图片\", \"anchor\" : \"5图片\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"6.链接\", \"anchor\" : \"6链接\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"7.**区块引⽤**\", \"anchor\" : \"7区块引⽤\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"8.**⾏内代码**\", \"anchor\" : \"8⾏内代码\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"9.**多⾏或者⼀段代码**\", \"anchor\" : \"9多⾏或者⼀段代码\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"10.**顺序图或流程图**\", \"anchor\" : \"10顺序图或流程图\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"12.**删除线**\", \"anchor\" : \"12删除线\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"13.**分隔线**\", \"anchor\" : \"13分隔线\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"14.MathJax\", \"anchor\" : \"14mathjax\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"15.**脚注（Footnote**）\", \"anchor\" : \"15脚注footnote\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"16.**注释和阅读更多**\", \"anchor\" : \"16注释和阅读更多\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"17.TOC\", \"anchor\" : \"17toc\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] } ]"
  },
  {
    "_id": "60d6bc2fa214c8473c32ae2a",
    "categoryId": "60f8ca03c7517f1c080b2075",
    "commentNumber": "0",
    "createDate": "1627459640377",
    "description": "主要介绍变量的用法，以及在 js 中如何声明变量",
    "htmlContent": "<h2>2-2 变量</h2>\n<p>接下来我们需要探讨一下对于任何编程语言来讲都是非常重要的一个东西，<strong>变量</strong>。所谓变量，就是用于引用内存中存储的一个值。当然，我们在使用变量之前，还需要先做的一件事儿就是声明变量。</p>\n<h3>2-2-1 声明变量</h3>\n<p>在 JavaScript 中声明变量的方式有3种：<code data-backticks=\"1\">var</code>，<code data-backticks=\"1\">let</code>，<code data-backticks=\"1\">const</code>。其中<code data-backticks=\"1\">var</code>现在已经不推荐使用了，因为会有变量提升等问题。（后面我们会具体来探讨此问题） <code data-backticks=\"1\">const</code>和<code data-backticks=\"1\">let</code>的区别在于，<code data-backticks=\"1\">const</code>所声明的变量如果是简单数据类型，那么是不能够再改变的。而<code data-backticks=\"1\">let</code>所声明的变量无论是简单数据类型还是复杂数据类型，在后面是可以改变的。示例如下： const 声明变量：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">const name = 'Bill';\nname = 'Lucy';\n// TypeError: Assignment to constant variable.\n</code></pre>\n<p>let 声明变量：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let name = 'Bill';\nname = 'Lucy';\nconsole.log(name);\n</code></pre>\n<h3>2-2-2 变量的赋值与初始化</h3>\n<p>我们可以利用<code data-backticks=\"1\">=</code>来给一个变量进行赋值，给变量第一次赋值的过程，叫做变量的初始化。一般我们在声明变量的时候就会将变量给初始化，如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = 3;\n</code></pre>\n<p>当然我们也可以一次性初始化多个变量，将其写在一行里面。</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let x = 3,y = 4,z = 5;\n</code></pre>\n<p>如果声明变量时没有赋予初值，那么默认值为<code data-backticks=\"1\">undefined</code></p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a;\nconsole.log(a); // undefined\n</code></pre>\n<h3>2-2-3 使用 var 声明变量</h3>\n<p>前面有提到过，在 JavaScript 中声明变量的方式有3种：<code data-backticks=\"1\">var</code>，<code data-backticks=\"1\">let</code>，<code data-backticks=\"1\">const</code>。其中<code data-backticks=\"1\">var</code>现在已经不推荐使用了。这是因为使用<code data-backticks=\"1\">var</code>来声明变量会伴随着一些问题。当然，这些问题也经常被看作是 JavaScript 的一些特点。这里要介绍到的是<strong>重复声明</strong>和<strong>遗漏声明</strong>。</p>\n<h4>重复声明</h4>\n<p>如果是使用<code data-backticks=\"1\">var</code>关键字来声明的变量，那么是允许重复声明的。只不过这个时候会忽略此次声明。如果重新声明并且带有赋值，则相当于是重新赋值 重复声明不带有赋值操作，JavaScript 引擎会自动忽略后面的变量声明：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">var test = 3;\nvar test;\nconsole.log(test); // 3\n</code></pre>\n<p>重新声明时如果带有赋值操作，那么会进行一个数据的覆盖：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">var test = 3;\nvar test = 5;\nconsole.log(test); // 5\n</code></pre>\n<p>需要注意的是，重复声明仅仅是使用<code data-backticks=\"1\">var</code>关键字时可以这样。如果是在严格模式中，或者使用<code data-backticks=\"1\">let</code>或者<code data-backticks=\"1\">const</code>的话是会报错的。</p>\n<h4>遗漏声明</h4>\n<p>如果试图读取一个没有声明的变量的值，JavaScript 引擎会报错：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(a);\n// ReferenceError: a is not defined\n</code></pre>\n<p>但是 JavaScript 引擎允许遗漏声明。即直接对变量赋值而无需事先声明，赋值操作会自动声明该变量：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">{\n    a = 5;\n    console.log(a); // 5\n}\nconsole.log(a); // 5\n</code></pre>\n<h3>2-2-4 作用域</h3>\n<p>所谓作用域，就是变量在程序中能够被访问到的区域。这里我们介绍一个全局作用域，一个局部作用域</p>\n<h4>1. 全局作用域</h4>\n<p>这是 JavaScript 引擎一进来就处于的运行环境。在全局作用域的中所声明变量称之为全局变量。全局变量的特点在于变量在任何地方都能被访问，如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = 5; // 这是一个全局变量\n</code></pre>\n<h4>2. 局部作用域</h4>\n<p>在 JavaScript 中，一对大括号就可以产生一个局部作用域。局部作用域里面的变量称之为局部变量。既然是局部变量，那么就只能在这个局部的作用域里面能访问到，外部是访问不到的，如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">{\n    let i = 10;\n    console.log(i); // 10\n}\nconsole.log(i);\n// ReferenceError: i is not defined\n</code></pre>\n<p>顺带一提的是，在大括号中用<code data-backticks=\"1\">var</code>声明的变量不是局部变量，而是一个全局变量。这其实也是最早使用<code data-backticks=\"1\">var</code>来声明变量所遗留下来的一个问题，如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">{\n    var i = 10;\n    console.log(i); // 10\n}\nconsole.log(i); // 10\n</code></pre>\n<p>在局部作用域里面，如果变量名和全局作用域里面的变量名冲突，优先使用局部作用域里面的变量：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let i = 10;\n{\n    let i = 100;\n    console.log(i); // 100\n}\nconsole.log(i); // 10\n</code></pre>\n<p>如果在局部作用域里面声明变量时没有书写关键字，那么会声明一个全局变量：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">{\n    i = 10;\n}\nconsole.log(i); // 10\n</code></pre>",
    "scanNumber": "18",
    "thumb": "/static/upload/2021-6-29-10-52-17-338-e950d.jpeg",
    "title": "变量",
    "toc": "[ ]"
  },
  {
    "_id": "60d6d93f5b14c54eb53c7e65",
    "categoryId": "60f8ca03c7517f1c080b2075",
    "commentNumber": "1",
    "createDate": "1624693055641",
    "description": "这是关于 js 中数据类型的文章",
    "htmlContent": "<h2>2-3 数据类型</h2>\n<p>所谓数据类型，就是指数据不同的种类。 在 JavaScript 中，存在 6 种简单数据类型以及 1 种复杂数据类型。接下来，就让我们首先一起来看一下 JavaScript 中 6 种简单的数据类型。</p>\n<h3>2-3-1 undefined 类型</h3>\n<p><code data-backticks=\"1\">undefined</code>类型就只有一个值，undefined。在使用变量但是没有为其赋值的时候，这个变量的值就是 undefined。 还需要注意一点，就是没有申明的变量，使用时会报错，而不是 undefined。但是打印其类型的时候，显示的类型却是 undefined</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let i;\nconsole.log(typeof i); // undefined\nconsole.log(typeof j); // undefined\nconsole.log(i); // undefined\nconsole.log(j);\n// ReferenceError: j is not defined\n</code></pre>\n<h3>2-3-2 null 类型</h3>\n<p><code data-backticks=\"1\">null</code>类型的值也是只有一个，就是 null。<code data-backticks=\"1\">null</code>表示一个空的对象。从逻辑角度来看，null 值表示一个空对象指针，这也正是用<code data-backticks=\"1\">typeof</code>操作符检测 null 值时会返回 object 的原因。 示例：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let i = null;\nconsole.log(typeof i); // object\n</code></pre>\n<p>实际上，undefined 值是从 null 值派生而来的，因此当我们对这两个数据类型进行相等测试时，会返回true。如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">if(null == undefined){\n    console.log('Yes'); // Yes\n}\n</code></pre>\n<h3>2-3-3 布尔类型</h3>\n<p>布尔类型，也被称为<code data-backticks=\"1\">boolean</code>类型。这个类型的值只有两个，一个是 true，另一个是 false。</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let i = true;\nconsole.log(i); // true\nconsole.log(typeof i); // boolean\n</code></pre>\n<p>需要注意的是，这两个值与数字值不是一回事，因此 true 不一定等于 1，而 false 也不一定等于0。 还有一点就是布尔类型的字面值 true 和 false 是区分大小写的。也就是说，True 和 False 都不是布尔值。 虽然布尔类型的字面值只有 2 个，但是 ECMAScript 中所有类型的值都可以转换为布尔类型。可以使用<code data-backticks=\"1\">Boolean()</code>函数将其他类型转换为布尔值。</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(Boolean(&quot;Hello&quot;)); // true\nconsole.log(Boolean(42)); // true\nconsole.log(Boolean(0)); // false\n</code></pre>\n<p>最后需要注意的就是下面的 9 个值是对应着布尔类型里面的假值：</p>\n<ul>\n<li>\n<p>&quot;&quot;：双引号的空字符串</p>\n</li>\n<li>\n<p>''：单引号的空字符串</p>\n</li>\n<li>\n<p>``：空字符串模板</p>\n</li>\n<li>\n<p>0：数字0</p>\n</li>\n<li>\n<p>-0：JavaScript 中 -0 和 0 为不同的值</p>\n</li>\n<li>\n<p>NaN</p>\n</li>\n<li>\n<p>false</p>\n</li>\n<li>\n<p>null</p>\n</li>\n<li>\n<p>undefined</p>\n</li>\n</ul>\n<h3>2-3-4 数字类型</h3>\n<p>数字类型又被称之为<code data-backticks=\"1\">number</code>类型。<code data-backticks=\"1\">number</code>类型的值可以分为整数和实数两大类。</p>\n<h4>1. 整数</h4>\n<p>整数可以分为正整数和负整数，如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = 12;\nlet b = -7;\n</code></pre>\n<p>这个虽然没什么好说的，但是还是有一个注意点，那就是进制问题。二进制以<code data-backticks=\"1\">0b</code>开头，八进制以<code data-backticks=\"1\">0</code>开头，十六进制以<code data-backticks=\"1\">0x</code>开头，示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">// 二进制\nlet a = 0b101; // 5\n// 八进制\nlet b = 017; // 15\n// 十进制\nlet c = 21; // 21\n// 十六进制\nlet d = 0xFD; // 253\nconsole.log(a,b,c,d);\n</code></pre>\n<p>需要注意的是，不管参与运算的变量是多少进制，最终计算结果仍然会为十进制。 在 ECMAScript 6 中提供了八进制数值新的写法，使用<code data-backticks=\"1\">0o</code>作为前缀，如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = 017;\nlet b = 0o17;\nconsole.log(a,b); // 15 15\n</code></pre>\n<h4>2. 实数</h4>\n<p>所谓实数，就是我们平常所常见的小数，或者称之为浮点数。在 JavaScript 里面，表示浮点数的方式有两种，小数型和科学记数法型。示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = 3.14;\nlet b = 9.12e+2;\nconsole.log(a,b); // 3.14 912\n</code></pre>\n<h4>3. 数值范围（扩展）</h4>\n<p>由于内存限制，JavaScript 并不能保存世界上所有的数值。在 JavaScript 中能够表示的最小数值在绝大多数浏览器中为<code data-backticks=\"1\">5e-324</code>，而最大值为<code data-backticks=\"1\">1.7976931348623157e+308</code>。 通过<code data-backticks=\"1\">Number.MIN_VALUE</code>和<code data-backticks=\"1\">Number.MAX_VALUE</code>我们可以查看到 JavaScript 中支持的最小值和最大值：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(Number.MIN_VALUE); // 5e-324\nconsole.log(Number.MAX_VALUE); // 1.7976931348623157e+308\n</code></pre>\n<p>如果某次计算的结果超出了 ECMAScript 的数值范围，那么正数会被转化为<code data-backticks=\"1\">infinity</code>（正无穷），负数会被转换为<code data-backticks=\"1\">-infinity</code>（负无穷）。例如，根据 ECMAScript 的规定： 大于等于 2 的 1024 次方的数为无穷大</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let i = Math.pow(2,1024);\nconsole.log(i); // Infinity\n</code></pre>\n<p>小于等于 2 的 1024 次方的数为无穷小</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let i = -Math.pow(2,1024);\nconsole.log(i); // -Infinity\n</code></pre>\n<p>如果某次计算返回了 infinity 值，那么该值无法参与下一次计算。因为 infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的，可以使用<code data-backticks=\"1\">isFinite()</code>函数。 示例：如果是无穷大数，会返回 false，否则返回 true（其实这个函数就是用于判断一个变量是否为数值的）</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let i = Math.pow(2,1024);\nconsole.log(isFinite(i)); // fasle\nlet j = 7;\nconsole.log(isFinite(j)); // true\n</code></pre>\n<h4>4. NaN</h4>\n<p>英文全称为 Not a Number，即非数值。这个数值用于表示本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。NaN 有两个特点： <strong>1. 任何涉及 NaN 的操作都会返回 NaN</strong></p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = NaN + 10;\nconsole.log(a); // NaN\n</code></pre>\n<p><strong>2. NaN 和任何值都不相等，包括它自己本身</strong></p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(NaN === NaN); // false\n</code></pre>\n<p>除此之外，ECMAScript 还定义了一个<code data-backticks=\"1\">isNaN()</code>函数，来判断一个参数是否不是数值。<code data-backticks=\"1\">isNaN()</code>函数在接收到一个值之后，会尝试将这个值转换为数值。示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(isNaN(NaN)); // true\nconsole.log(isNaN(&quot;123&quot;)); // false\nconsole.log(isNaN(123)); // false\nconsole.log(isNaN(&quot;Hello&quot;)); // true\nconsole.log(isNaN(true)); // false\n</code></pre>\n<p>最后需要补充说明一下的是，NaN是属于<code data-backticks=\"1\">number</code>类型的：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(typeof NaN); // number\n</code></pre>\n<h4>5. 数值转换</h4>\n<p>在 JavaScript 里面，有 3 个函数可以将非数值的数据转为数值，分别是<code data-backticks=\"1\">Number()</code>，<code data-backticks=\"1\">parseInt()</code>以及<code data-backticks=\"1\">parseFloat()</code>。下面我们将依次对这几个方法进行介绍： <strong>Number()</strong>：可以将非数值转为数值。有下面几个规则需要注意：</p>\n<ul>\n<li>\n<p>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0</p>\n</li>\n<li>\n<p>如果是数字，那么就是简单的传入和返回</p>\n</li>\n<li>\n<p>如果是 null 值，那么返回 0</p>\n</li>\n<li>\n<p>如果是 undefined，那么返回 NaN</p>\n</li>\n</ul>\n<p>示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(Number(true)); // 1\nconsole.log(Number(false)); // 0\nconsole.log(Number(10)); // 10\nconsole.log(Number(null)); // 0\nconsole.log(Number(undefined)); // NaN\n</code></pre>\n<p>如果是字符串，那么又有如下的规则：</p>\n<ul>\n<li>\n<p>如果字符串只包含数字，则将其转为十进制，即 &quot;1&quot; 会变成 1，&quot;123&quot; 变成 123，而 &quot;011&quot; 会变为 11（注意这里不会被当成八进制来处理）</p>\n</li>\n<li>\n<p>如果字符串中包含小数点，如 &quot;1.1&quot;，则将其转换为对应的浮点数值</p>\n</li>\n<li>\n<p>如果字符串中包含有效的十六进制格式，例如 &quot;0xf&quot;，则会将其转换为相同大小的十进制整数</p>\n</li>\n<li>\n<p>如果字符串是空的，则将其转换为 0</p>\n</li>\n<li>\n<p>如果字符串包含上述格式之外的字符，则将其转换为 NaN</p>\n</li>\n</ul>\n<p>示例：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(Number(&quot;1&quot;)); // 1\nconsole.log(Number(&quot;012&quot;)); // 12\nconsole.log(Number(&quot;0o10&quot;)); // 8\nconsole.log(Number(&quot;0b111&quot;)); // 7\nconsole.log(Number(&quot;3.14&quot;)); // 3.14\nconsole.log(Number(&quot;0xf&quot;)); // 15\nconsole.log(Number(&quot;&quot;)); // 0\nconsole.log(Number(&quot;123Hello&quot;)); // NaN\n</code></pre>\n<p><strong>parseInt()</strong>：也是将一个非数值转为数值。 说明：相比<code data-backticks=\"1\">Number()</code>函数，<code data-backticks=\"1\">parseInt()</code>会更多的看是否有数字，有就会将其转换为数值。 最简单的例子为<code data-backticks=\"1\">Number()</code>函数转换 &quot;123Hello&quot; 时会转换为 NaN，而<code data-backticks=\"1\">parseInt()</code>则会将其转换为 123。 碰到空字符串时，<code data-backticks=\"1\">Number()</code>函数会将其转换为 0，而<code data-backticks=\"1\">parseInt()</code>则会将其转换为 NaN 最后是在碰到小数时，会有一个取整的过程。例如 &quot;3.14&quot; 会被转换为 &quot;3&quot; 示例：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(parseInt(&quot;1&quot;)); // 1\nconsole.log(parseInt(&quot;012&quot;)); // 12\nconsole.log(Number(&quot;0o10&quot;)); // 8\nconsole.log(Number(&quot;0b111&quot;)); // 7\nconsole.log(parseInt(&quot;3.14&quot;)); // 3\nconsole.log(parseInt(&quot;0xf&quot;)); // 15\nconsole.log(parseInt(&quot;&quot;)); // NaN\nconsole.log(parseInt(&quot;123Hello&quot;)); // 123\n</code></pre>\n<p>我们的<code data-backticks=\"1\">parseInt()</code>从 ECMAScript 5 开始还提供了第二个参数，那就是指定参数是多少进制，这样<code data-backticks=\"1\">parseInt()</code>函数就可以将指定的进制转换为十进制，如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(parseInt(&quot;012&quot;)); // 12\nconsole.log(parseInt(&quot;012&quot;,8)); // 10\n// 如果是 16 进制数,后面添加上参数 16 后,字符串前面可以不写0x\nconsole.log(parseInt(&quot;AF&quot;));//NaN\nconsole.log(parseInt(&quot;AF&quot;,16));//175\n</code></pre>\n<p>除此之外，我们的<code data-backticks=\"1\">parseInt()</code>函数的第 2 个参数还可以是任意值，8 进制前面不用加前面的0，十六进制不用加前面的 0x</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(parseInt(&quot;21&quot;,3)); // 7\nconsole.log(parseInt(&quot;10&quot;,2)); // 2\nconsole.log(parseInt(&quot;11&quot;,8)); // 9\nconsole.log(parseInt(&quot;AF&quot;,16)); // 175\n</code></pre>\n<p><strong>parseFloat()</strong>：将非数值转为浮点数 说明：<code data-backticks=\"1\">parseFloat()</code>只解析十进制值，所以没有第二个参数，该函数会将带有小数点的字符串转换为小数。如果没有小数点的数会被转换为整数。 同样的<code data-backticks=\"1\">parseFloat()</code>也是尽可能转换更多的数值。例如 &quot;123Hello&quot; 会被转换为 123</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(parseFloat(&quot;21&quot;)); // 21\nconsole.log(parseFloat(&quot;123Hello&quot;)); // 123\nconsole.log(parseFloat(&quot;0xA&quot;)); // 0\nconsole.log(parseFloat(&quot;3.14&quot;)); // 3.14\nconsole.log(parseFloat(&quot;22.34.5&quot;)); // 22.34\nconsole.log(parseFloat(&quot;0908.34&quot;)); // 908.34\nconsole.log(parseFloat(&quot;3.1415e2&quot;)); // 314.15\n</code></pre>\n<p>ECMAScript 6 将全局方法<code data-backticks=\"1\">parseInt()</code>和<code data-backticks=\"1\">parseFloat()</code>等方法，移植到<code data-backticks=\"1\">Number</code>类上面，行为完全保持不变，这么做的目的，是为了逐步减少全局性的方法，使得语言逐步模块化。</p>\n<pre class=\"lang-js\"><code data-language=\"js\">// ES5的写法\nconsole.log(parseInt(&quot;12.34&quot;)); // 12\nconsole.log(parseFloat(&quot;12.34#&quot;)); // 12.34\n\n// ES6的写法\nconsole.log(Number.parseInt(&quot;12.34&quot;)); // 12\nconsole.log(Number.parseFloat(&quot;12.34#&quot;)); // 12.34\n</code></pre>\n<h4>6. 静态方法（扩展）</h4>\n<p>这里是第一次听到静态方法这个说法。什么是静态方法呢？ 所谓静态方法，主要是涉及到了面向对象里面的知识，这里简单理解，就是通过该类型能够直接调用的方法。下面介绍两个数字类型的静态方法。 <strong>Number.isInteger()</strong>：用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，整数和浮点数是同样的存储方法，所以 3 和 3.0 被视为同一个值。</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(Number.isInteger(25)); // true\nconsole.log(Number.isInteger(25.0)); // true\nconsole.log(Number.isInteger(25.1)); // false\nconsole.log(Number.isInteger(&quot;15&quot;)); // false\nconsole.log(Number.isInteger(true)); // false\n</code></pre>\n<p><strong>Number.isFinite()</strong>：这个方法我们前面在介绍数值范围的时候已经给大家介绍过了。如果一个值是字符串，布尔类型，Infinity，-Infinity，NaN 等(总之就不是数字的时候)，则返回 false，如果是数字的话就会返回 true。并且不会进行自动类型转换。</p>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log(Number.isFinite(true)); // false\nconsole.log(Number.isFinite(7)); // true\nconsole.log(Number.isFinite(NaN)); // false\nconsole.log(Number.isFinite(Infinity)); // false\nconsole.log(Number.isFinite(&quot;23&quot;)); // false\n</code></pre>\n<h4>7. 实例方法（扩展）</h4>\n<p>首先解释一下什么叫做实例方法。所谓实例方法，就是指必须要实例化对象，然后在对象上面调用。这也涉及到了后面面向对象的知识。现在只需要知道要先有一个数，然后在这个数上面调用相应的方法。 <strong>toFixed()</strong>：该方法会按照指定的小数位，返回数值四舍五入后的字符串表示（常用于处理货币值）</p>\n<blockquote>\n<p>注意：toFixed()里的参数只接受 0 - 20，若不传参或参数为 undefined 则相当于参数是 0</p>\n</blockquote>\n<pre class=\"lang-js\"><code data-language=\"js\">let num = 10.456;\nconsole.log(num.toFixed(2)); // 10.46\nconsole.log(num.toFixed()); // 10\nconsole.log(num.toFixed(0)); // 10\nconsole.log(num.toFixed(undefined)); // 10\nconsole.log(num.toFixed(-1)); // 报错\n// RangeError: toFixed() digits argument must be between 0 and 20\n</code></pre>\n<p><strong>toExponential()</strong>：返回数值四舍五入后的指数表示法（e表示法）的字符串表示，参数为转换后的小数位数</p>\n<blockquote>\n<p>注意：该方法里的参数只接受 0 - 20，但与<code data-backticks=\"1\">toFxied()</code>不同的是，若不传参或参数为 undefined，则保留尽可能多的有效数字，若参数是 0 则表示没有小数部分</p>\n</blockquote>\n<pre class=\"lang-js\"><code data-language=\"js\">let num = 10.456;\nconsole.log(num.toExponential(2)); // 1.05e+1\nconsole.log(num.toExponential()); // 1.0456e+1\nconsole.log(num.toExponential(0)); // 1e+1\nconsole.log(num.toExponential(undefined)); // 1.0456e+1\nconsole.log(num.toExponential(-1)); // 报错\n// RangeError: toExponential() argument must be between 0 and 20\n</code></pre>\n<p><strong>toPrecision()</strong>：接收 1 个参数，表示数值的总位数，自动调用<code data-backticks=\"1\">toFixed()</code>或<code data-backticks=\"1\">toExponential()</code></p>\n<blockquote>\n<p>注意：<code data-backticks=\"1\">toPrecision()</code>里的参数只接受 1 - 21，若不传参或参数为 undefined 则相当于调用<code data-backticks=\"1\">toString()</code>方法，转换后的数值总位数不含指数部分</p>\n</blockquote>\n<pre class=\"lang-js\"><code data-language=\"js\">let num = 10.456;\nconsole.log(num.toPrecision(3)); // 10.5\nconsole.log(num.toPrecision(2)); // 10\nconsole.log(num.toPrecision(1)); // 1e+1\nconsole.log(num.toPrecision()); // 10.456\nconsole.log(num.toPrecision(undefined)); // 10.456\nconsole.log(num.toPrecision(0)); // 报错\n// RangeError: toPrecision() argument must be between 1 and 21\n</code></pre>\n<blockquote>\n<p>注意：<code data-backticks=\"1\">toFixed()</code>、<code data-backticks=\"1\">toExponential()</code>、<code data-backticks=\"1\">toPrecision()</code>这三个方法在小数位用于四舍五入时都不太可靠，跟浮点数不是精确储存有关</p>\n</blockquote>\n<pre class=\"lang-js\"><code data-language=\"js\">console.log((12.25).toPrecision(3)); // 12.3\nconsole.log((12.25).toFixed(1)); // 12.3\nconsole.log((12.25).toExponential(2)); // 1.23e+1\nconsole.log((12.35).toPrecision(3)); // 12.3\nconsole.log((12.35).toFixed(1)); // 12.3\nconsole.log((12.35).toExponential(2)); // 1.23e+1\n</code></pre>\n<h3>2-3-5 字符串类型</h3>\n<h4>1. 字符串介绍</h4>\n<p>这是程序里面使用最为广泛的一种类型。在 JavaScript 里面，可以使用单引号，也可以使用双引号</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = &quot;abcd&quot;;\nlet b = 'abcd';\n</code></pre>\n<p>这里需要注意一个问题，就是字符串的内容本身包含单引号或者双引号的话，需要和字符串界限符区分开，如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = &quot;Hello 'World',welcome&quot;; // 正确\nlet b = 'Hello &quot;World&quot;,welcome'; // 正确\nlet c = &quot;Hello &quot;World&quot;,welcome&quot;; // 错误\n</code></pre>\n<p>当然，我们这里使用转义字符也是一个很好的选择，如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = &quot;Hello 'World',welcome&quot;; // 正确\nlet b = 'Hello &quot;World&quot;,welcome'; // 正确\nlet c = &quot;Hello \\&quot;World\\&quot;,welcome&quot;; // 正确\n</code></pre>\n<p>字符串这种数据类型非常的霸道，它和其他数据类型相加都会被转换为字符串类型，示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = &quot;abcd&quot;;\nlet b = 13 + a;\nlet c = 3.14 + a;\nlet d = true + a;\nlet e = null + a;\nlet f = undefined + a;\nconsole.log(typeof b); // string\nconsole.log(typeof c); // string\nconsole.log(typeof d); // string\nconsole.log(typeof e); // string\nconsole.log(typeof f); // string\n</code></pre>\n<p>所以如果我们要让一个非字符串的变量转换为字符串的话，只需要和一个空字符串相加就可以了。 当然，转换字符串事实上我们也有相应的函数来转换，最常见的就是<code data-backticks=\"1\">toString()</code>函数。 <strong>toString()</strong> 说明：该函数会将除了 null 和 undefined 以外的数据类型转换为字符串。 示例：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = 10,b = true,c = null,d;\nconsole.log(typeof a.toString()); // string\nconsole.log(typeof b.toString()); // string\nconsole.log(typeof c.toString()); // 报错\nconsole.log(typeof d.toString());\n</code></pre>\n<p>可以看到，程序报错，因为 null 和 undefined 并不能通过<code data-backticks=\"1\">toString()</code>函数来转换为相应的字符串。 还有一个知识点，就是<code data-backticks=\"1\">toString()</code>函数在转换数值的时候是可以带有参数的。可以将数值指定转换为几进制。示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let i = 10;\nconsole.log(i.toString()); // 10\nconsole.log(i.toString(2)); // 1010\nconsole.log(i.toString(8)); // 12\nconsole.log(i.toString(10)); // 10\nconsole.log(i.toString(16)); // a\n</code></pre>\n<p>当想要将 null 和 undefined 转换成字符串时，可以使用<code data-backticks=\"1\">String()</code>方法。该方法可以将 5 种数据类型都转换为字符串。示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = 10,b = true,c = null,d;\nconsole.log(String(a),typeof String(a)); // 10 string\nconsole.log(String(b),typeof String(b)); // true string\nconsole.log(String(c),typeof String(c)); // null string\nconsole.log(String(d),typeof String(d)); // undefined string\n</code></pre>\n<h4>2. 字符串模板</h4>\n<p>在 ECMAScript 6 中新增了模板字面量。这可以看作是增强版的字符串，它用反引号 ` 进行标识：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let str = `Hello World`;\nconsole.log(str); // Hello World\nconsole.log(typeof str); // string\nconsole.log(str.length); // 11\n</code></pre>\n<p>以上代码中，使用模板字面量语法创建一个字符串，并赋值给 str 变量，这时变量的值与一个普通的字符串无异。 如果想在字符串中包含反引号，只需使用反斜杠<code data-backticks=\"1\">\\</code>转义即可。 ECMAScript 6 的模板字面量使得多行字符串更加容易创建，因为它不需要特殊的语法，只需要在想要的位置直接换行即可，如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let str = `Hello \nWorld`;\nconsole.log(str);\n// Hello\n// World\nconsole.log(typeof str); // string\nconsole.log(str.length); // 12\n</code></pre>\n<p>在反引号之内的所有空白符都是字符串的一部分，因此需要特别留意缩进。 模板字面量看上去仅仅是普通 JavaScript 字符串的升级版，但二者之间真正的区别在于模版字面量存在变量占位符。变量占位符允许将任何有效的 JavaScript 表达式嵌入到模板字面量中，并将其结果输出为字符串的一部分。 变量占位符由起始的<code data-backticks=\"1\">${</code>与结束的<code data-backticks=\"1\">}</code>来界定，之间允许放入任意的 JavaScript 表达式。示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let name = &quot;xiejie&quot;;\nconsole.log(`Hello,${name}`);\n// Hello,xiejie\n</code></pre>\n<p>占位符<code data-backticks=\"1\">${name}</code>会访问本地变量<code data-backticks=\"1\">name</code>，并将其值插入到字符串中。 既然占位符是可以是 JavaScript 表达式，那么可替换的就不仅仅是简单的变量名，可以轻易嵌入运算符、函数调用等，示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let count = 10,price = 0.25;\nconsole.log(`${count} items cost $${(count*price).toFixed(2)}`);\n// 10 items cost $2.50\n</code></pre>\n<h3>2-3-6 symbol类型</h3>\n<p>ECMAScript 5 中包含 5 种原始类型：字符串、数字、布尔值、null 和 undefined。ECMAScript 6 引入了第 6 种原始类型：symbol ECMAScript 5 的对象属性名都是字符串，很容易造成属性名冲突。比如，使用了一个他人提供的对象，想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名冲突。这就是 ECMAScript 6 引入 symbol 的原因。 我们将在讲解面向对象的时候再具体来讲解 symbol 类型。</p>\n<h3>2-3-7 简单值和复杂值的区别（扩展）</h3>\n<p>至此，在 JavaScript 中除了 symbol 以外的简单数据类型，就给大家介绍完了。还剩下一种复杂数据类型，那就是对象，我们会在第 6 章中进行详细的介绍。 这里要给大家扩展的一个知识点，那就是简单数据类型所创建的值被称之为简单值，而复杂数据类型所创建的值被称之为复杂值。 那么简单值和复杂值具体有什么区别呢？下面我们一个一个来看：</p>\n<h4>1. 简单值（或原始值）</h4>\n<p><strong>简单值是表示 JavaScript 中可用的数据或信息的最底层形式或最简单形式。简单类型的值被称为简单值，是因为它们是不可细化</strong>的。 也就是说，数字是数字，字符是字符，布尔值是 true 或 false，null 和 undefined 就是 null 和 undefined。这些值本身很简单，不能够再进行拆分。由于简单值的数据大小是固定的，所以<strong>简单值的数据是存储于内存中的栈区里面的。</strong></p>\n<pre class=\"lang-js\"><code data-language=\"js\">let str = &quot;Hello World&quot;;\nlet num = 10;\nlet bol = true;\nlet myNull = null;\nlet undef = undefined;\nconsole.log(typeof str); // string\nconsole.log(typeof num); // number\nconsole.log(typeof bol); // boolean\nconsole.log(typeof myNull); // object\nconsole.log(typeof undef); // undefined\n</code></pre>\n<p>这里面就 null 和 undefined 比较特殊，打印出来的数据类型分别是<code data-backticks=\"1\">object</code>和<code data-backticks=\"1\">undefined</code>。因为这两个数据类型没有对应的构造函数，当然什么是构造函数我们后面再说，现在我们只需要将 null 和 undefined 看作是特殊的操作符来使用即可。</p>\n<h4>2. 复杂值</h4>\n<p>在 JavaScript 中，对象就是一个复杂值。因为对象可以向下拆分，拆分成多个简单值或者复杂值。<strong>复杂值在内存中的大小是未知的，因为复杂值可以包含任何值，而不是一个特定的已知值，所以复杂值的数据都是存储于堆区里面。</strong></p>\n<pre class=\"lang-js\"><code data-language=\"js\">// 简单值\nlet str = &quot;Hello World&quot;;\nlet num = 10;\nlet bol = true;\nlet myNull = null;\nlet undef = undefined;\n// 复杂值\nlet obj = {\n    name : 'xiejie',\n    age : 18,\n    isPassed : true\n};\nlet arr = [1,2,3,&quot;Hello&quot;,true];\n</code></pre>\n<h4>3. 访问方式</h4>\n<p><strong>按值访问</strong> 简单值是作为不可细化的值进行存储和使用的，引用它们会转移其值。</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let str = &quot;Hello&quot;;\nlet str2 = str;\nstr = null;\nconsole.log(str,str2); // null &quot;Hello&quot;\n</code></pre>\n<p><strong>引用访问</strong> 复杂值是通过引用进行存储和操作的，而不是实际的值。创建一个包含复杂对象的变量时，其值是内存中的一个引用地址。引用一个复杂对象时，使用它的名称（即变量或对象属性）通过内存中的引用地址获取该对象值。</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let obj = {};\nlet obj2 = obj;\nobj.name = &quot;xiejie&quot;;\nconsole.log(obj.name); // xiejie\nconsole.log(obj2.name); // xiejie\n</code></pre>\n<h4>4. 比较方式</h4>\n<p>简单值采用值比较，而复杂值采用引用比较。复杂值只有在引用相同的对象（即有相同的地址）时才相等。即使是包含相同对象的两个变量也彼此不相等，因为它们并不指向同一个对象 示例1:</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = 10;\nlet b = 10;\nlet c = new Number(10);\nlet d = c;\nconsole.log(a === b); // true\nconsole.log(a === c); // false\nconsole.log(a == c); // true\nd = 10;\nconsole.log(d == c); // true\nconsole.log(d === c); // false\n</code></pre>\n<p>示例2:</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let obj = {name : 'xiejie'};\nlet obj2 = {name : 'xiejie'};\nconsole.log(obj == obj2); // false\nconsole.log(obj === obj2); // false\nlet obj3 = {name : 'xiejie'};\nlet obj4 = obj3;\nconsole.log(obj3 == obj4); // true\nconsole.log(obj3 === obj4); // ture\n</code></pre>\n<h4>5. 动态属性</h4>\n<p>对于复杂值，可以为其添加属性和方法，也可以改变和删除其属性和方法。但简单值不可以：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let str = 'test';\nstr.abc = true;\nconsole.log(str.abc); // undefined\nlet obj = {};\nobj.abc = true;\nconsole.log(obj.abc); // true\n</code></pre>\n<p>复杂值支持动态对象属性，因为我们可以定义对象，然后创建引用，再更新对象，并且所有指向该对象的变量都会获得更新。 一个新变量指向现有的复杂对象，并没有复制该对象。这就是复杂值有时被称为引用值的原因。复杂值可以根据需求有任意多个引用，即使对象改变，它们也总是指向同一个对象</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let obj = {name : 'xiejie'};\nlet obj2 = obj;\nlet obj3 = obj2;\nobj.name = 'abc';\nconsole.log(obj.name,obj2.name,obj3.name);\n// abc abc abc\n</code></pre>\n<h4>6. 变量赋值</h4>\n<p>最后说一下关于变量的赋值，其实是可以分为直接赋值和引用赋值的。直接赋值，就是指将简单值赋值给变量，而引用赋值是指将一个复杂值的引用赋值给变量，这个引用指向堆区实际存在的数据。 <strong>直接赋值</strong></p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = 3;\nlet b = a;\nb = 5;\nconsole.log(a); // 3\n</code></pre>\n<p><strong>引用赋值</strong></p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = {value : 1};\nlet b = a;\nb.value = 10;\nconsole.log(a.value); // 10\n</code></pre>\n<h3>2-3-8 类型转换</h3>\n<p>通过前面的介绍，我们已经知道了在 JavaScript 中有好几种不同的数据类型。然而这些数据类型都是可以相互转换的。类型转换可以分为两种，<strong>隐性转换</strong>和<strong>显性转换</strong>。 <strong>1. 隐性转换</strong> 当不同数据类型之间进行相互运算，或者当对非布尔类型的数据求布尔值的时候，会发生隐性转换。 预期为数字的时候：算术运算的时候，我们的结果和运算的数都是数字，数据会转换为数字来进行计算。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>转换前</th>\n<th>转换后</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>number</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>string</td>\n<td>&quot;1&quot;</td>\n<td>1</td>\n</tr>\n<tr>\n<td>string</td>\n<td>&quot;abc&quot;</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>string</td>\n<td>&quot;&quot;</td>\n<td>0</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>true</td>\n<td>1</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>false</td>\n<td>0</td>\n</tr>\n<tr>\n<td>undefined</td>\n<td>undefined</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>null</td>\n<td>null</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>预期为字符串的时候：如果有一个操作数为字符串时，使用<code data-backticks=\"1\">+</code>符号做相加运算时，会自动转换为字符串。 预期为布尔的时候：前面在介绍布尔类型时所提到的 9 个值会转为 false，其余转为 true <strong>2. 显性转换</strong> 所谓显性转换，就是只程序员强制将一种类型转换为另外一种类型。显性转换往往会使用到一些转换方法。常见的转换方法如下：</p>\n<ul>\n<li>\n<p>转换为数值类型：<code data-backticks=\"1\">Number()</code>，<code data-backticks=\"1\">parseInt()</code>，<code data-backticks=\"1\">parseFloat()</code></p>\n</li>\n<li>\n<p>转换为布尔类型：<code data-backticks=\"1\">Boolean()</code></p>\n</li>\n<li>\n<p>转换为字符串类型：<code data-backticks=\"1\">toString()</code>，<code data-backticks=\"1\">String()</code></p>\n</li>\n</ul>\n<p>当然，除了使用上面的转换方法，我们也可以通过一些快捷方式来进行数据类型的显性转换，如下：</p>\n<ul>\n<li>\n<p>转换字符串：直接和一个空字符串拼接，例如：<code data-backticks=\"1\">a = &quot;&quot; + 数据</code></p>\n</li>\n<li>\n<p>转换布尔：!!数据类型，例如：<code data-backticks=\"1\">!!&quot;Hello&quot;</code></p>\n</li>\n<li>\n<p>转换数值：数据*1 或 /1，例如：<code data-backticks=\"1\">&quot;Hello * 1&quot;</code></p>\n</li>\n</ul>",
    "scanNumber": "31",
    "thumb": "/static/upload/2023-4-10-22-4-56-949-5a2aa.png",
    "title": "数据类型精讲",
    "toc": "[ { \"name\" : \"2-3 数据类型\", \"anchor\" : \"2-3-数据类型\", \"children\" : [ { \"name\" : \"2-3-1 undefined 类型\", \"anchor\" : \"2-3-1-undefined-类型\" }, { \"name\" : \"2-3-2 null 类型\", \"anchor\" : \"2-3-2-null-类型\" }, { \"name\" : \"2-3-3 布尔类型\", \"anchor\" : \"2-3-3-布尔类型\" }, { \"name\" : \"2-3-4 数字类型\", \"anchor\" : \"2-3-4-数字类型\", \"children\" : [ { \"name\" : \"1. 整数\", \"anchor\" : \"1-整数\" }, { \"name\" : \"2. 实数\", \"anchor\" : \"2-实数\" }, { \"name\" : \"3. 数值范围（扩展）\", \"anchor\" : \"3-数值范围扩展\" }, { \"name\" : \"4. NaN\", \"anchor\" : \"4-nan\" }, { \"name\" : \"5. 数值转换\", \"anchor\" : \"5-数值转换\" }, { \"name\" : \"6. 静态方法（扩展）\", \"anchor\" : \"6-静态方法扩展\" }, { \"name\" : \"7. 实例方法（扩展）\", \"anchor\" : \"7-实例方法扩展\" } ] }, { \"name\" : \"2-3-5 字符串类型\", \"anchor\" : \"2-3-5-字符串类型\", \"children\" : [ { \"name\" : \"1. 字符串介绍\", \"anchor\" : \"1-字符串介绍\" }, { \"name\" : \"2. 字符串模板\", \"anchor\" : \"2-字符串模板\" } ] }, { \"name\" : \"2-3-6 symbol类型\", \"anchor\" : \"2-3-6-symbol类型\" }, { \"name\" : \"2-3-7 简单值和复杂值的区别（扩展）\", \"anchor\" : \"2-3-7-简单值和复杂值的区别扩展\", \"children\" : [ { \"name\" : \"1. 简单值（或原始值）\", \"anchor\" : \"1-简单值或原始值\" }, { \"name\" : \"2. 复杂值\", \"anchor\" : \"2-复杂值\" }, { \"name\" : \"3. 访问方式\", \"anchor\" : \"3-访问方式\" }, { \"name\" : \"4. 比较方式\", \"anchor\" : \"4-比较方式\" }, { \"name\" : \"5. 动态属性\", \"anchor\" : \"5-动态属性\" }, { \"name\" : \"6. 变量赋值\", \"anchor\" : \"6-变量赋值\" } ] }, { \"name\" : \"2-3-8 类型转换\", \"anchor\" : \"2-3-8-类型转换\" } ] } ]"
  },
  {
    "_id": "60da8872e088c229aab1da28",
    "categoryId": "60f8ca03c7517f1c080b2075",
    "commentNumber": "0",
    "createDate": "1681463633689",
    "description": "流程控制文章",
    "htmlContent": "<p>所谓流程控制整个程序的走向的。默认情况下，程序是从上往下，逐条执行，这种情况我们将其称之为顺序结构。但是并不是所有的程序都是使用顺序结构就能够完成的。在我们书写程序时往往还需要对整个程序进行分支，或者对某一段代码进行重复执行。 所以，在这一章我们就一起来看一下 JavaScript 中的流程控制语句。 本章中我们将学习如下的内容：</p><ul><li><p>条件语句</p></li><li><p>循环语句</p></li></ul><h2 id=\"h3-1-条件语句\">3-1 条件语句</h2><p>条件语句，主要就是给定一个判断条件，并在程序执行过程中判断该条件是否成立，然后根据判断结果来执行不同的操作，从而改变代码的执行顺序，实现更多的功能。 一般来讲，条件语句可以分为 3 种：单分支语句，双分支语句以及多分支语句，我们一个一个来看。</p><h3 id=\"h3-1-1-单分支语句\">3-1-1 单分支语句</h3><p>单分支语句，由一个<code data-backticks=\"1\">if</code>组成，如果条件成立，则进入代码块开始执行语句，单分支语句的语法如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">if(条件){\n    // 条件为真时执行的代码\n}</code></pre></div><p>示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let age = 20;\nif(age &gt;= 18){\n    console.log(\"你已经是成年人了\");\n}</code></pre></div><p>如果条件不是一个布尔值，那么会被自动转换为布尔值</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">if(1){\n    console.log(\"Hello\");\n}</code></pre></div><p>if 语句里面的花括弧不是必须的，当只有一条执行语句的时候，可以不使用花括弧，但是不推荐这么做</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">if(true)console.log(\"Hello\");</code></pre></div><h3 id=\"h3-1-2-双分支语句\">3-1-2 双分支语句</h3><p>顾名思义，就是有两个分支线，如果 if 条件不成立，那么就会跳入到 else 语句里面，语法如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">if(条件){\n    // 条件为真时要执行的代码\n}else{\n    // 条件为假时要执行的代码\n}</code></pre></div><p>示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let age = 16;\nif(age &gt;= 18){\n    console.log(\"你已经成年了\");\n}else{\n    console.log(\"你还是未成年\");\n}</code></pre></div><h4 id=\"h三目运算符\">三目运算符</h4><p><code data-backticks=\"1\">if...else</code>语句的一个缩写方式，就是使用三目运算符<code data-backticks=\"1\">?:</code> 语法：条件 ? （条件为真时执行的代码） : （条件为假时执行的代码） 示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let age = 16;\nlet result = age&gt;=18 ? \"你已经成年了\" : \"你还是未成年\";\nconsole.log(result); // 你还是未成年</code></pre></div><p>练习：使用三目运算符来找出3个数中最大的那个数</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let a = 3,b = 8,c = 5;\nlet max = a&gt;b ? (a&gt;c?a:c) : (b&gt;c?b:c);\nconsole.log(max); // 8</code></pre></div><h3 id=\"h3-1-3-多分支语句\">3-1-3 多分支语句</h3><p>多个<code data-backticks=\"1\">if...else</code>语句可以组合在一起，形成逻辑决策树：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">if(条件){\n    // 执行语句\n}else if(条件){\n    // 执行语句\n}else{\n    // 执行语句\n}</code></pre></div><p>需要注意的就是在多分支语句里面，如果进入到了某一个语句块，那么后面的条件就不会再进行判断，而是会直接跳出，多分支语句示例如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const readline = require(\"readline-sync\");\nconsole.log(\"请输入你的成绩:\");\nlet score = readline.question(\"\");\nif(score &gt; 100 || score &lt; 0){\n    console.log(\"成绩输入有误\");\n}else if(score &gt;= 90){\n    console.log(\"优秀\");\n}else if(score &gt;= 70){\n    console.log(\"良好\");\n}else if(score &gt;= 60){\n    console.log(\"合格\");\n}else{\n    console.log(\"不合格\");\n}</code></pre></div><h4 id=\"hswitch-语句\">switch 语句</h4><p>有一种比多分支语句结构更加清晰的语句结构，就是 switch 语句。语法如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">switch(条件){\n    case 1:\n        // 执行语句;\n        break;\n    case 2:\n        // 执行语句;\n        break;\n    case 3:\n        // 执行语句;\n        break;\n    default:\n        // 执行语句;\n}</code></pre></div><p>示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let num = 2;\nswitch(num){\n    case 1:\n        console.log(\"the number is one\");\n        break;\n    case 2:\n        console.log(\"the number is two\");\n        break;\n    default:\n        console.log(\"neither one nor two\");\n}\n// the number is two</code></pre></div><p>这里特别需要说明的是，switch 语句中的条件和分支入口进行的是全等比较，示例如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let i = \"2\";\nswitch (i) {\n    case 2:\n        console.log('this is one');\n        break;\n    case \"2\":\n        console.log('this is two');\n        break;\n    default:\n        console.log('this is default');\n}\n// 打印结果为：this is two</code></pre></div><p>还有一点，在 JavaScript 里面的 switch 语句中，和其他静态语言有所不同的是，case 后面的值不一定必须是常量，可以是变量甚至是表达式，只要 switch 的条件和 case 入口匹配上即可，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">switch(false){\n    case 2 &lt; 3:\n        console.log(\"进入了第一个入口\");\n        break;\n    case 6 &lt; 3:\n        console.log(\"进入了第二个入口\");\n        break;\n    default:\n        console.log(\"进入了默认入口\");\n}\n// 进入了第二个入口</code></pre></div><p><strong>break关键字</strong> <code data-backticks=\"1\">break</code>用于跳出某一个 case，如果不书写 break 的话，进入 case 以后会继续进入后面的case语句。break 往往存在一个误区，就是觉得这个关键字是必须要写的，但是并不是必须要写。有些时候我们故意不写break 关键字反而能给我们带来便利，例如下面的例子：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let day = 4;\nswitch(day){\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        console.log(\"今天是工作日\");\n        break;\n    case 6:\n    case 7:\n        console.log(\"今天是周末\");\n        break;\n    default:\n        console.log(\"输入有误\");\n}</code></pre></div><p>这里我们希望程序在变量 day 值为 1 - 5 时输出\"今天是工作日\"，在值为 6 和 7 的时候输出\"今天是周末\"。这个时候就可以通过省略<code data-backticks=\"1\">break</code>关键字来节省我们的代码量。 <strong>default关键字</strong> <code data-backticks=\"1\">default</code>用于书写默认的条件，如果前面都不满足的话，就进入到 default 语句里面。 default 往往也会存在误区，很多人认为 default 也是必须要写的。事实上 default 也是可以省略的，我们书写 default ，只是为了对 switch 没有进入 case 语句时的情况做一种默认操作。当然，作为良好的编码习惯，应该在每一个 switch 语句里面书写上 default。</p>",
    "scanNumber": "28",
    "thumb": "/static/upload/2023-4-10-22-4-56-949-5a2aa.png",
    "title": "第 3 章 流程控制语句",
    "toc": "[ { \"name\" : \"3-1 条件语句\", \"anchor\" : \"3-1-条件语句\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ { \"name\" : \"3-1-1 单分支语句\", \"anchor\" : \"3-1-1-单分支语句\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"3-1-2 双分支语句\", \"anchor\" : \"3-1-2-双分支语句\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ { \"name\" : \"三目运算符\", \"anchor\" : \"三目运算符\", \"level\" : { \"$numberInt\" : \"4\" }, \"children\" : [ ] } ] }, { \"name\" : \"3-1-3 多分支语句\", \"anchor\" : \"3-1-3-多分支语句\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ { \"name\" : \"switch 语句\", \"anchor\" : \"switch-语句\", \"level\" : { \"$numberInt\" : \"4\" }, \"children\" : [ ] } ] } ] } ]"
  },
  {
    "_id": "60dab0d4a26be02ed73e75a7",
    "categoryId": "60f8ca03c7517f1c080b2075",
    "commentNumber": "0",
    "createDate": "1624944852218",
    "description": "数组",
    "htmlContent": "<p>所谓数据结构，就是计算机存储和组织数据的方式。说得通俗一点，主要就是指将数据以什么样的结构存储到计算机里面。<br>\n在程序里面，最为常见的数据结构，就是数组，这种结构将多个数据有序的排列在一起，形成了一个组合。除了数组以外，集合，映射等 ECMAScript 6 新增加的数据结构，也会在本章中向大家详细介绍。<br>\n本章中我们将学习如下的内容：</p>\n<ul>\n<li>\n<p>数组基础知识</p>\n</li>\n<li>\n<p>数组相关属性和方法</p>\n</li>\n<li>\n<p>集合</p>\n</li>\n<li>\n<p>映射</p>\n</li>\n</ul>\n<h2>4-1 数组基础</h2>\n<p>数组是大多数语言里面最常见的一种数据结构，它是一个有序的值列表。</p>\n<h3>4-1-1 创建数组</h3>\n<p>创建数组的方式大致可以分为两种：字面量创建数组和使用构造函数创建数组。示例如下：<br>\n<strong>1. 字面量创建数组</strong></p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = [];\n</code></pre>\n<p><strong>2. 构造函数创建数组</strong></p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = new Array();\n</code></pre>\n<p>需要注意的是，无论是字面量形式创建的数组，还是构造函数创建的数组，当我们使用<code data-backticks=\"1\">typeof</code>来打印其数据类型的时候，都会返回一个<code data-backticks=\"1\">object</code>，如下：</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr1 = [];\nlet arr2 = new Array();\nconsole.log(typeof arr1); // object\nconsole.log(typeof arr2); // object\n</code></pre>\n<h3>4-1-2 数组赋值</h3>\n<p>给数组赋值的方法也非常简单，不过可以分为先声明再赋值和声明时直接赋值，如下：<br>\n<strong>1. 先声明再赋值</strong></p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = [];\narr[0] = 1;\narr[1] = 2;\narr[2] = 3;\n</code></pre>\n<p>注意下标是从 0 开始的。<br>\n<strong>2. 声明时直接赋值</strong></p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = [1,2,3,4,5];\n</code></pre>\n<p>需要注意的是我们可以在数组的任意位置进行赋值，数组的长度会自动改变，空的位置使用<code data-backticks=\"1\">undefined</code>来进行填充</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = [];\narr[0] = 1;\narr[4] = 10;\nconsole.log(arr);\n// [ 1, &lt;3 empty items&gt;, 10 ]\n</code></pre>\n<p>由于 JavaScript 是动态语言，所以 JavaScript 里面数组的数据类型可以是任意类型</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = [1,&quot;Hello&quot;,3.14,true];\n</code></pre>\n<h3>4-1-3 访问数组元素</h3>\n<p>通过数组的下标，我们可以轻松的访问到存储在数组里面的元素，如下：</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = [1,2,3,4,5];\nconsole.log(arr[0]); // 1\n</code></pre>\n<blockquote>\n<p>需要注意数组里面的第一个元素是从下标 0 开始的。</p>\n</blockquote>\n<p>除了这种常规的访问方式，我们还可以使用变量的方式来进行访问，如下：</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = [1,2,3,4,5];\nlet i = 2;\nconsole.log(arr[i]); // 3\n</code></pre>\n<h3>4-1-4 删除元素</h3>\n<p>我们可以使用<code data-backticks=\"1\">delete</code>运算符来删除数组中的某一个元素，示例如下：</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = [1,2,3,4,5];\ndelete arr[2]; // 删除数组中的第3个元素\nconsole.log(arr);\n// [ 1, 2, &lt;1 empty item&gt;, 4, 5 ]\n</code></pre>\n<h3>4-1-5 数组的遍历</h3>\n<p>接下来我们来看一下数组的遍历，在 JavaScript 中，遍历数组的方式非常的多。这里先介绍几种常见的数组遍历方式。<br>\n<strong>通过 for 循环来遍历数组</strong><br>\n最简单的方式就是通过<code data-backticks=\"1\">for</code>循环来进行数组的遍历，这也是一直以来被使用得最多的方式，示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let arr = [1, 2, 3, 4, 5];\nfor (let i=0;i&lt;arr.length;i++) {\n    console.log(arr[i]);\n}\n// 1\n// 2\n// 3\n// 4\n// 5\n</code></pre>\n<p><strong>通过 for-in 来遍历数组</strong><br>\n<code data-backticks=\"1\">for-in</code>主要迭代的是数组的键，然后我们通过键就可以找到相应的数组元素，示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let arr = [1, 2, 3, 4, 5];\nfor (let i in arr) {\n    console.log(`键为${i}的元素值为${arr[i]}`);\n}\n// 键为 0 的元素值为 1\n// 键为 1 的元素值为 2\n// 键为 2 的元素值为 3\n// 键为 3 的元素值为 4\n// 键为 4 的元素值为 5\n</code></pre>\n<p><strong>通过 for-of 来遍历数组</strong><br>\n上面介绍的<code data-backticks=\"1\">for-in</code>是迭代数组的键，这里所介绍的<code data-backticks=\"1\">for-of</code>是直接迭代数组的值，示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let arr = [1, 2, 3, 4, 5];\nfor (let i of arr) {\n    console.log(i);\n}\n// 1\n// 2\n// 3\n// 4\n// 5\n</code></pre>\n<p><strong>通过 forEach 来遍历数组（扩展）</strong><br>\n最后再介绍一种通过<code data-backticks=\"1\">forEach</code>的方式来遍历数组，不过这里涉及到了回调函数的知识。在第 5 章我们就会学习回调函数，所以这里大家先了解一下这种遍历的方式即可，示例如下：</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = [1,2,3,4,5,6,7,8,9,10];\n// 将数组的每一项传入到回调函数，然后执行回调函数里面的操作\nlet i = arr.forEach(function(item){\n    console.log(item);\n});\n</code></pre>\n<p><strong>使用迭代器进行遍历</strong><br>\n在 ECMAScript 6 中，还专门提供了 3 个用于迭代可迭代元素的方法，分别是<code data-backticks=\"1\">keys()</code>，<code data-backticks=\"1\">values()</code>以及<code data-backticks=\"1\">entries()</code>方法。<br>\n其中<code data-backticks=\"1\">keys()</code>是找到可迭代元素的键，<code data-backticks=\"1\">values()</code>是找到可迭代元素的值，<code data-backticks=\"1\">entries()</code>是同时找到可迭代元素的键和值。<br>\n示例：使用<code data-backticks=\"1\">keys()</code>方法遍历出数组的键</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let arr = [3,5,8,1];\nfor(let i of arr.keys()){\n    console.log(i);\n}\n// 0\n// 1\n// 2\n// 3\n</code></pre>\n<p>示例：使用<code data-backticks=\"1\">values()</code>方法遍历出数组的值</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let arr = [3,5,8,1];\nfor(let i of arr.values()){\n    console.log(i);\n}\n// 3\n// 5\n// 8\n// 1\n</code></pre>\n<blockquote>\n<p>注意：根据 Node.js 环境的版本，可能出现数组里面无法使用<code data-backticks=\"1\">values()</code>方法情况。</p>\n</blockquote>\n<p>示例：使用<code data-backticks=\"1\">entries()</code>方法遍历出数组的键和值</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let arr = [3,5,8,1];\nfor(let i of arr.entries()){\n    console.log(i);\n}\n// [ 0, 3 ]\n// [ 1, 5 ]\n// [ 2, 8 ]\n// [ 3, 1 ]\n</code></pre>\n<h3>4-1-6 解构数组</h3>\n<p>首先我们需要了解什么是解构，所谓解构，就是将一个复杂类型的数据分解为一个普通类型数据。解构是从 ECMAScript 6 开始新添加的功能。可以对数组和对象进行解构。<br>\n这里我们先来看一下数组的解构，如下：</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = [1,2,3];\nlet [a,b,c] = arr;\nconsole.log(a); // 1\nconsole.log(b); // 2\nconsole.log(c); // 3\n</code></pre>\n<p>这里，就是将 arr 这个数组里面的值分解给了 a，b，c<br>\n可以使用逗号来跳过不想要解构的元素，如下：</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let arr = [1,2,3];\nlet [a,,b] = arr;\nconsole.log(a); // 1\nconsole.log(b); // 3\n</code></pre>\n<p>在解构出现之前，我们交换两个数需要使用到一个中间变量，但是现在我们可以使用解构来交换两个数</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let a = 1,b = 2;\n[a,b] = [b,a];\nconsole.log(a); // 2\nconsole.log(b); // 1\n</code></pre>\n<p>关于对象的解构，我们会在后面进行介绍，详细参见对象的相关章节。</p>\n<h3>4-1-7 多维数组</h3>\n<p>首先需要说明的是，JavaScript 里面不支持传统编程语言中的多维数组。但是，由于 JavaScript 的数组里面所存放的数据的数据类型可以是任意类型，所以我们可以模拟出多维数组</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let a = [&quot;Bill&quot;,&quot;Mary&quot;,&quot;Lucy&quot;];\nlet b = [21,24,27];\nlet c = [a,b]; // 这里 c 就是一个多维数组\n</code></pre>\n<p>如果要访问多维数组里面的数据，可以使用下面的形式</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let a = [&quot;Bill&quot;,&quot;Mary&quot;,&quot;Lucy&quot;];\nlet b = [21,24,27];\nlet c = [a,b];\nconsole.log(c[0][2]); // Lucy\n</code></pre>\n<p>利用前面所介绍的解构，我们可以来解构一个多维数组，示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let arr = [[1,2,3],4,5];\nlet [a,b,c] = arr;\nconsole.log(a); // [1,2,3]\nconsole.log(b); // 4\nconsole.log(c); // 5\n</code></pre>\n<h3>4-1-8 扩展运算符</h3>\n<p>扩展运算符是 ECMAScript 6 开始新添加的运算符，用于取出可迭代对象的每一项。这里我们可以用它来快速的展开一个数组</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let a = [&quot;Bill&quot;,&quot;Mary&quot;,&quot;Lucy&quot;];\nlet b = [21,24,27];\nlet c = [...a,...b];\nconsole.log(c);\n// [ 'Bill', 'Mary', 'Lucy', 21, 24, 27 ]\n</code></pre>\n<p>我们再来看一个例子：</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let a = [1,2,3];\nlet b = [...a,4,5,6];\nconsole.log(b);\n// [ 1, 2, 3, 4, 5, 6 ]\n</code></pre>\n<p>有了这个运算符以后，我们可以使用它将字符串快速转为数组</p>\n<pre class=\"lang-javascript\"><code data-language=\"javascript\">let str = &quot;Hello&quot;;\nlet arr = [...str];\nconsole.log(arr);\n// [ 'H', 'e', 'l', 'l', 'o' ]\n</code></pre>",
    "scanNumber": "4",
    "thumb": "/static/upload/2023-4-10-22-4-56-949-5a2aa.png",
    "title": "第 4 章 数据结构",
    "toc": "[ { \"name\" : \"4-1 数组基础\", \"anchor\" : \"4-1-数组基础\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ { \"name\" : \"4-1-1 创建数组\", \"anchor\" : \"4-1-1-创建数组\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"4-1-2 数组赋值\", \"anchor\" : \"4-1-2-数组赋值\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"4-1-3 访问数组元素\", \"anchor\" : \"4-1-3-访问数组元素\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"4-1-4 删除元素\", \"anchor\" : \"4-1-4-删除元素\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"4-1-5 数组的遍历\", \"anchor\" : \"4-1-5-数组的遍历\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"4-1-6 解构数组\", \"anchor\" : \"4-1-6-解构数组\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"4-1-7 多维数组\", \"anchor\" : \"4-1-7-多维数组\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"4-1-8 扩展运算符\", \"anchor\" : \"4-1-8-扩展运算符\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] } ] } ]"
  },
  {
    "_id": "60dab161a26be02ed73e75a8",
    "categoryId": "60f8ca03c7517f1c080b2075",
    "commentNumber": "0",
    "createDate": "1624944993668",
    "description": "流程控制语句",
    "htmlContent": "<p>所谓流程控制，主要就是用于控制整个程序的走向的。默认情况下，程序是从上往下，逐条执行，这种情况我们将其称之为顺序结构。但是并不是所有的程序都是使用顺序结构就能够完成的。在我们书写程序时往往还需要对整个程序进行分支，或者对某一段代码进行重复执行。 所以，在这一章我们就一起来看一下 JavaScript 中的流程控制语句。 本章中我们将学习如下的内容：</p>\n<ul>\n<li>\n<p>条件语句</p>\n</li>\n<li>\n<p>循环语句</p>\n</li>\n</ul>\n<h2>3-1 条件语句</h2>\n<p>条件语句，主要就是给定一个判断条件，并在程序执行过程中判断该条件是否成立，然后根据判断结果来执行不同的操作，从而改变代码的执行顺序，实现更多的功能。 一般来讲，条件语句可以分为 3 种：单分支语句，双分支语句以及多分支语句，我们一个一个来看。</p>\n<h3>3-1-1 单分支语句</h3>\n<p>单分支语句，由一个<code data-backticks=\"1\">if</code>组成，如果条件成立，则进入代码块开始执行语句，单分支语句的语法如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">if(条件){\n    // 条件为真时执行的代码\n}\n</code></pre>\n<p>示例：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let age = 20;\nif(age &gt;= 18){\n    console.log(&quot;你已经是成年人了&quot;);\n}\n</code></pre>\n<p>如果条件不是一个布尔值，那么会被自动转换为布尔值</p>\n<pre class=\"lang-js\"><code data-language=\"js\">if(1){\n    console.log(&quot;Hello&quot;);\n}\n</code></pre>\n<p>if 语句里面的花括弧不是必须的，当只有一条执行语句的时候，可以不使用花括弧，但是不推荐这么做</p>\n<pre class=\"lang-js\"><code data-language=\"js\">if(true)console.log(&quot;Hello&quot;);\n</code></pre>\n<h3>3-1-2 双分支语句</h3>\n<p>顾名思义，就是有两个分支线，如果 if 条件不成立，那么就会跳入到 else 语句里面，语法如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">if(条件){\n    // 条件为真时要执行的代码\n}else{\n    // 条件为假时要执行的代码\n}\n</code></pre>\n<p>示例：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let age = 16;\nif(age &gt;= 18){\n    console.log(&quot;你已经成年了&quot;);\n}else{\n    console.log(&quot;你还是未成年&quot;);\n}\n</code></pre>\n<h4>三目运算符</h4>\n<p><code data-backticks=\"1\">if...else</code>语句的一个缩写方式，就是使用三目运算符<code data-backticks=\"1\">?:</code> 语法：条件 ? （条件为真时执行的代码） : （条件为假时执行的代码） 示例：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let age = 16;\nlet result = age&gt;=18 ? &quot;你已经成年了&quot; : &quot;你还是未成年&quot;;\nconsole.log(result); // 你还是未成年\n</code></pre>\n<p>练习：使用三目运算符来找出3个数中最大的那个数</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let a = 3,b = 8,c = 5;\nlet max = a&gt;b ? (a&gt;c?a:c) : (b&gt;c?b:c);\nconsole.log(max); // 8\n</code></pre>\n<h3>3-1-3 多分支语句</h3>\n<p>多个<code data-backticks=\"1\">if...else</code>语句可以组合在一起，形成逻辑决策树：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">if(条件){\n    // 执行语句\n}else if(条件){\n    // 执行语句\n}else{\n    // 执行语句\n}\n</code></pre>\n<p>需要注意的就是在多分支语句里面，如果进入到了某一个语句块，那么后面的条件就不会再进行判断，而是会直接跳出，多分支语句示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">const readline = require(&quot;readline-sync&quot;);\nconsole.log(&quot;请输入你的成绩:&quot;);\nlet score = readline.question(&quot;&quot;);\nif(score &gt; 100 || score &lt; 0){\n    console.log(&quot;成绩输入有误&quot;);\n}else if(score &gt;= 90){\n    console.log(&quot;优秀&quot;);\n}else if(score &gt;= 70){\n    console.log(&quot;良好&quot;);\n}else if(score &gt;= 60){\n    console.log(&quot;合格&quot;);\n}else{\n    console.log(&quot;不合格&quot;);\n}\n</code></pre>\n<h4>switch 语句</h4>\n<p>有一种比多分支语句结构更加清晰的语句结构，就是 switch 语句。语法如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">switch(条件){\n    case 1:\n        // 执行语句;\n        break;\n    case 2:\n        // 执行语句;\n        break;\n    case 3:\n        // 执行语句;\n        break;\n    default:\n        // 执行语句;\n}\n</code></pre>\n<p>示例：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let num = 2;\nswitch(num){\n    case 1:\n        console.log(&quot;the number is one&quot;);\n        break;\n    case 2:\n        console.log(&quot;the number is two&quot;);\n        break;\n    default:\n        console.log(&quot;neither one nor two&quot;);\n}\n// the number is two\n</code></pre>\n<p>这里特别需要说明的是，switch 语句中的条件和分支入口进行的是全等比较，示例如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let i = &quot;2&quot;;\nswitch (i) {\n    case 2:\n        console.log('this is one');\n        break;\n    case &quot;2&quot;:\n        console.log('this is two');\n        break;\n    default:\n        console.log('this is default');\n}\n// 打印结果为：this is two\n</code></pre>\n<p>还有一点，在 JavaScript 里面的 switch 语句中，和其他静态语言有所不同的是，case 后面的值不一定必须是常量，可以是变量甚至是表达式，只要 switch 的条件和 case 入口匹配上即可，如下：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">switch(false){\n    case 2 &lt; 3:\n        console.log(&quot;进入了第一个入口&quot;);\n        break;\n    case 6 &lt; 3:\n        console.log(&quot;进入了第二个入口&quot;);\n        break;\n    default:\n        console.log(&quot;进入了默认入口&quot;);\n}\n// 进入了第二个入口\n</code></pre>\n<p><strong>break关键字</strong> <code data-backticks=\"1\">break</code>用于跳出某一个 case，如果不书写 break 的话，进入 case 以后会继续进入后面的case语句。break 往往存在一个误区，就是觉得这个关键字是必须要写的，但是并不是必须要写。有些时候我们故意不写break 关键字反而能给我们带来便利，例如下面的例子：</p>\n<pre class=\"lang-js\"><code data-language=\"js\">let day = 4;\nswitch(day){\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        console.log(&quot;今天是工作日&quot;);\n        break;\n    case 6:\n    case 7:\n        console.log(&quot;今天是周末&quot;);\n        break;\n    default:\n        console.log(&quot;输入有误&quot;);\n}\n</code></pre>\n<p>这里我们希望程序在变量 day 值为 1 - 5 时输出&quot;今天是工作日&quot;，在值为 6 和 7 的时候输出&quot;今天是周末&quot;。这个时候就可以通过省略<code data-backticks=\"1\">break</code>关键字来节省我们的代码量。 <strong>default关键字</strong> <code data-backticks=\"1\">default</code>用于书写默认的条件，如果前面都不满足的话，就进入到 default 语句里面。 default 往往也会存在误区，很多人认为 default 也是必须要写的。事实上 default 也是可以省略的，我们书写 default ，只是为了对 switch 没有进入 case 语句时的情况做一种默认操作。当然，作为良好的编码习惯，应该在每一个 switch 语句里面书写上 default。</p>",
    "scanNumber": "7",
    "thumb": "/static/upload/2023-4-10-22-4-56-949-5a2aa.png",
    "title": "第 3 章 流程控制语句",
    "toc": "[ { \"name\" : \"3-1 条件语句\", \"anchor\" : \"3-1-条件语句\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ { \"name\" : \"3-1-1 单分支语句\", \"anchor\" : \"3-1-1-单分支语句\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"3-1-2 双分支语句\", \"anchor\" : \"3-1-2-双分支语句\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ { \"name\" : \"三目运算符\", \"anchor\" : \"三目运算符\", \"level\" : { \"$numberInt\" : \"4\" }, \"children\" : [ ] } ] }, { \"name\" : \"3-1-3 多分支语句\", \"anchor\" : \"3-1-3-多分支语句\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ { \"name\" : \"switch 语句\", \"anchor\" : \"switch-语句\", \"level\" : { \"$numberInt\" : \"4\" }, \"children\" : [ ] } ] } ] } ]"
  },
  {
    "_id": "60dab94d12b5443071ac8c00",
    "categoryId": "60f8ca03c7517f1c080b2075",
    "commentNumber": "0",
    "createDate": "1624947020979",
    "description": "变量测试",
    "htmlContent": "<h1>你好</h1>\n<h3>你好吗</h3>\n<h2>你好好</h2>\n<h1>哈哈哈</h1>\n<h2>撒打算大</h2>",
    "scanNumber": "23",
    "thumb": "/static/upload/2023-4-10-22-4-56-949-5a2aa.png",
    "title": "2-2 变量",
    "toc": "[ { \"name\" : \"2-2-1 声明变量\", \"anchor\" : \"2-2-1-声明变量\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"2-2-2 变量的赋值与初始化\", \"anchor\" : \"2-2-2-变量的赋值与初始化\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ ] }, { \"name\" : \"2-2-3 使用 var 声明变量\", \"anchor\" : \"2-2-3-使用-var-声明变量\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ { \"name\" : \"重复声明\", \"anchor\" : \"重复声明\", \"level\" : { \"$numberInt\" : \"4\" }, \"children\" : [ ] }, { \"name\" : \"遗漏声明\", \"anchor\" : \"遗漏声明\", \"level\" : { \"$numberInt\" : \"4\" }, \"children\" : [ ] } ] }, { \"name\" : \"2-2-4 作用域\", \"anchor\" : \"2-2-4-作用域\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ { \"name\" : \"1. 全局作用域\", \"anchor\" : \"1-全局作用域\", \"level\" : { \"$numberInt\" : \"4\" }, \"children\" : [ ] }, { \"name\" : \"2. 局部作用域\", \"anchor\" : \"2-局部作用域\", \"level\" : { \"$numberInt\" : \"4\" }, \"children\" : [ ] } ] } ]"
  },
  {
    "_id": "60f90ecdc7517f1c080b21d4",
    "categoryId": "60e3f4eaafb11203748a0f68",
    "commentNumber": "11",
    "createDate": "1627456708287",
    "description": "这是一篇有内涵的文章22233333",
    "htmlContent": "<h2>标题1111333</h2>\n<p>这是标题1的内容</p>\n<h2>标题2222333</h2>\n<p>这是标题2 的内容</p>\n<ul>\n<li>\n<p>苹果</p>\n</li>\n<li>\n<p>香蕉</p>\n</li>\n</ul>\n<p>这是测试文章的全部内容。333</p>",
    "scanNumber": "37",
    "thumb": "/static/upload/2023-4-10-22-4-56-949-5a2aa.png",
    "title": "这是一篇测试文章222333",
    "toc": "[ ]"
  },
  {
    "_id": "60ff9ea3bc2b960312b5f80b",
    "categoryId": "6431406e68949c11e8ca90d5",
    "commentNumber": "1",
    "createDate": "1681131177221",
    "description": "测试",
    "htmlContent": "<h2 id=\"标题1111333\">标题1111333</h2><p>这是标题1的内容</p><h2 id=\"标题2222333\">标题2222333</h2><p>这是标题2 的内容</p><ul><li><p>苹果</p></li><li><p>香蕉</p></li></ul><p>这是测试文章的全部内容。333</p>",
    "scanNumber": "21",
    "thumb": "/static/upload/2023-4-10-22-4-56-949-5a2aa.png",
    "title": "这是一篇新的测试文章44",
    "toc": "[ { \"name\" : \"标题1111333\", \"anchor\" : \"标题1111333\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"标题2222333\", \"anchor\" : \"标题2222333\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] } ]"
  },
  {
    "_id": "61132767c98aa404143fe231",
    "categoryId": "60f900eac7517f1c080b20e1",
    "commentNumber": "0",
    "createDate": "1628645223857",
    "description": "123",
    "htmlContent": "<p>CESHI</p>",
    "scanNumber": "18",
    "thumb": "/static/upload/2023-4-10-22-4-56-949-5a2aa.png",
    "title": "123321",
    "toc": "[ ]"
  },
  {
    "_id": "61133c17da8f390a74ce52ee",
    "categoryId": "643141bf68949c11e8ca9123",
    "commentNumber": "0",
    "createDate": "1681123538928",
    "description": "代理服务器",
    "htmlContent": "<p>本文主要包含以下内容：</p><ul><li><p>什么是代理</p></li><li><p>正向代理</p></li><li><p>反向代理</p></li><li><p>总结</p></li></ul><h2 id=\"什么是代理\">什么是代理</h2><p>代理其实就是一个中介，<em>A</em> 和 <em>B</em> 本来可以直连，中间插入一个 <em>C</em>，<em>C</em> 就是中介。 刚开始的时候，代理多数是帮助内网 <em>client</em> 访问外网 <em>server</em> 用的。 后来出现了反向代理，\"反向\"这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内。</p><h2 id=\"正向代理\">正向代理</h2><p>正向代理类似一个跳板机，代理访问外部资源。</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了。</p>",
    "scanNumber": "46",
    "thumb": "/static/upload/2023-4-10-22-4-56-949-5a2aa.png",
    "title": "this is a test1",
    "toc": "[ { \"name\" : \"什么是代理\", \"anchor\" : \"什么是代理\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"正向代理\", \"anchor\" : \"正向代理\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] } ]"
  },
  {
    "_id": "61133f18b2fa580b92acd039",
    "categoryId": "60f900eac7517f1c080b20e1",
    "commentNumber": "0",
    "createDate": "1628651492215",
    "description": "123321",
    "htmlContent": "<p>本文主要包含以下内容：</p>\n<ul>\n<li>\n<p>什么是代理</p>\n</li>\n<li>\n<p>正向代理</p>\n</li>\n<li>\n<p>反向代理</p>\n</li>\n<li>\n<p>总结</p>\n</li>\n</ul>\n<h2 id=\"什么是代理\">什么是代理</h2>\n<p>代理其实就是一个中介，<em>A</em> 和 <em>B</em> 本来可以直连，中间插入一个 <em>C</em>，<em>C</em> 就是中介。<br>\n刚开始的时候，代理多数是帮助内网 <em>client</em> 访问外网 <em>server</em> 用的。<br>\n后来出现了反向代理，&quot;反向&quot;这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内。</p>\n<h2 id=\"正向代理\">正向代理</h2>\n<p>正向代理类似一个跳板机，代理访问外部资源。<br>\n比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了。</p>",
    "scanNumber": "10",
    "thumb": "/static/upload/2023-4-10-22-4-56-949-5a2aa.png",
    "title": "test22233",
    "toc": "[ { \"name\" : \"什么是代理\", \"anchor\" : \"什么是代理\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"正向代理\", \"anchor\" : \"正向代理\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] } ]"
  },
  {
    "_id": "6433d88c522ecf56b80f7123",
    "categoryId": "6431406e68949c11e8ca90d5",
    "commentNumber": "0",
    "createDate": "1681135498258",
    "description": "1212",
    "htmlContent": "<p>本文主要包含以下内容：</p><ul><li><p>什么是代理</p></li><li><p>正向代理</p></li><li><p>反向代理</p></li><li><p>总结</p></li></ul><h2 id=\"什么是代理\">什么是代理</h2><p>代理其实就是一个中介，<em>A</em> 和 <em>B</em> 本来可以直连，中间插入一个 <em>C</em>，<em>C</em> 就是中介。 刚开始的时候，代理多数是帮助内网 <em>client</em> 访问外网 <em>server</em> 用的。 后来出现了反向代理，\"反向\"这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内。</p><h2 id=\"正向代理\">正向代理</h2><p>正向代理类似一个跳板机，代理访问外部资源。</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了。</p>",
    "scanNumber": "6",
    "thumb": "/static/upload/2023-4-10-22-4-56-949-5a2aa.png",
    "title": "2",
    "toc": "[ { \"name\" : \"什么是代理\", \"anchor\" : \"什么是代理\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] }, { \"name\" : \"正向代理\", \"anchor\" : \"正向代理\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ ] } ]"
  },
  {
    "_id": "64342f37c5ea5f6270fc8447",
    "categoryId": "643141b968949c11e8ca911b",
    "commentNumber": "0",
    "createDate": "1681199776348",
    "description": "213123",
    "htmlContent": "<ul><li><p>12123<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAIAAAAP3aGbAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAHx0lEQVR4nO3dS25cRxBFQdLQ/rcsL4E1SKfzNCPGQn+emgc1uajvv3//fgEU/PN/fwCAV4IFZAgWkCFYQIZgARmCBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkCFYQIZgARmCBWQIFpAhWECGYAEZggVkCBaQ8Wfqhb6/v6dequjlesdPfUSPV1u+fP2pWzKnHvW1zxM1ePmpExaQIVhAhmABGYIFZAgWkCFYQIZgARmCBWQIFpAhWECGYAEZY1vCF4OTojWDK7DNrz813Fv++pt7wxfLn+eX/4G8cMICMgQLyBAsIEOwgAzBAjIEC8gQLCBDsIAMwQIyBAvIECwgY3VL+GJzmnRwurV5od7yUO7a/+y13eKja49xmRMWkCFYQIZgARmCBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGee2hB9s867Ag0O55WsQf/TBe8MP5oQFZAgWkCFYQIZgARmCBWQIFpAhWECGYAEZggVkCBaQIVhAhi3hnmujs4NDueLekE1OWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkCFYQIZgARmCBWSc2xJab/3o2oV6m+O+ZdG55QdzwgIyBAvIECwgQ7CADMECMgQLyBAsIEOwgAzBAjIEC8gQLCBjdUv4waOzF1PDtGuv86j41ZZ/sb/8D+SFExaQIVhAhmABGYIFZAgWkCFYQIZgARmCBWQIFpAhWECGYAEZggVkfP/yexmLpiayywPpa8veg/twfuSEBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkCFYQMbqRaovoldgbg7Tpt4rOpS79r9/8DFufqTlr++EBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkCFYQMbYlnDzsryp11meQV0bwU0Z/MwH/9dGPD6izR9/lBMWkCFYQIZgARmCBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGWNbws2h3LUL/gZfanMFdvDqxs3XufZeX9lLOTc5YQEZggVkCBaQIVhAhmABGYIFZAgWkCFYQIZgARmCBWQIFpAxtiV8ce26tGvjvq971zsur9I23+7gI7q2SD34B+KEBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkCFYQMb3b973/fIV2EGfOoJb/qV9MCcsIEOwgAzBAjIEC8gQLCBDsIAMwQIyBAvIECwgQ7CADMECMlbvJdwcuF274O+DRa9uvPZeBx38I3LCAjIEC8gQLCBDsIAMwQIyBAvIECwgQ7CADMECMgQLyBAsIGNsSzh1E9zL61x7r0dTH2nT8meeGp1tvs7gHYhmkj9ywgIyBAvIECwgQ7CADMECMgQLyBAsIEOwgAzBAjIEC8gQLCBDsICM7+JFoZu7zeLz+Rpd5I681/7b/ai4Rf/K/iCnOGEBGYIFZAgWkCFYQIZgARmCBWQIFpAhWECGYAEZggVkCBaQMbYlvLa6ii7Frhlcrm1efxv9VW9+7GuP+pETFpAhWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkCFYQIZgARl/pl5oc5r0wfcSFldgJpnXbP4RLe8NnbCADMECMgQLyBAsIEOwgAzBAjIEC8gQLCBDsIAMwQIyBAvIGNsSHrzCbMTj5Grzq1171I/v9fKxi1PKFwevd4xywgIyBAvIECwgQ7CADMECMgQLyBAsIEOwgAzBAjIEC8gQLCDj3L2EU5YnV9euSozeS3jtq70Y/OUXP/bybtEJC8gQLCBDsIAMwQIyBAvIECwgQ7CADMECMgQLyBAsIEOwgIzvzUFZcb60PJR7MfWRrn2eR9dWqwe5lxDg/ydYQIZgARmCBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGWNbQn50bSb5IroTvLaQHXTt678YfEROWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkCFYQIZgARmCBWT8mXohN8GN/JsX0Ue9eZ/gtUf0+HmiF25ucsICMgQLyBAsIEOwgAzBAjIEC8gQLCBDsIAMwQIyBAvIECwgQ7CAjLHx84trt4S+GNyITl2Bee2W0MdHdO0G0M0x9sFf/ubXH+SEBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkCFYQMbqlvDF5nzp4MLrxeYmcXAAeHCYNuLg99qcbS7/ETlhARmCBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkHFuS/jBrt0EtzyC27xz8JrBwd0H7wRfOGEBGYIFZAgWkCFYQIZgARmCBWQIFpAhWECGYAEZggVkCBaQYUu4pziCe3Hwey1fuThl6klOvc7Bx+iEBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkCFYQMa5LeHBq9CmbF7Mt7km+2AH94abb3fw6zthARmCBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkPG9OXD7YMXN3cG94bXx2i9/RAe/vhMWkCFYQIZgARmCBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGWNbQoD/mhMWkCFYQIZgARmCBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGYIFZAgWkCFYQIZgARmCBWQIFpAhWECGYAEZggVkCBaQIVhAhmABGYIFZPwLqkU6OCVEmXMAAAAASUVORK5CYII=\" contenteditable=\"false\"><br></p></li></ul>",
    "scanNumber": "9",
    "thumb": "/static/upload/2023-4-10-23-45-57-765-3d740.png",
    "title": "123",
    "toc": "[ ]"
  },
  {
    "_id": "64352505504c6d2144bf6f3d",
    "categoryId": "6431406e68949c11e8ca90d5",
    "commentNumber": "0",
    "createDate": "1682275359494",
    "description": "1212",
    "htmlContent": "<table><thead><tr><th><p>121212</p></th><th><p><br></p></th><th><p><br></p></th></tr></thead><tbody><tr><td><p><br></p></td><td><p><br></p></td><td><p><br></p></td></tr></tbody></table>",
    "scanNumber": "6",
    "thumb": "/static/upload/2023-4-24-2-42-38-624-28301.jpg",
    "title": "test",
    "toc": "[ ]"
  },
  {
    "_id": "6437aa1773fc45d618d97b33",
    "categoryId": "643141bf68949c11e8ca9123",
    "commentNumber": "0",
    "createDate": "1681463459050",
    "description": "12321312",
    "htmlContent": "<h1 id=\"h--好的\">--好的</h1><h2 id=\"h12312321312\">12312321312</h2><h3 id=\"h12312321312-1\">12312321312</h3><h4 id=\"h12312321312-2\">12312321312</h4><h5 id=\"h12312321312-3\">12312321312</h5><h6 id=\"h12312321312-4\">12312321312</h6>",
    "scanNumber": "72",
    "thumb": "",
    "title": "test",
    "toc": "[ { \"name\" : \"--好的\", \"anchor\" : \"--好的\", \"level\" : { \"$numberInt\" : \"1\" }, \"children\" : [ { \"name\" : \"12312321312\", \"anchor\" : \"12312321312\", \"level\" : { \"$numberInt\" : \"2\" }, \"children\" : [ { \"name\" : \"12312321312\", \"anchor\" : \"12312321312-1\", \"level\" : { \"$numberInt\" : \"3\" }, \"children\" : [ { \"name\" : \"12312321312\", \"anchor\" : \"12312321312-2\", \"level\" : { \"$numberInt\" : \"4\" }, \"children\" : [ { \"name\" : \"12312321312\", \"anchor\" : \"12312321312-3\", \"level\" : { \"$numberInt\" : \"5\" }, \"children\" : [ { \"name\" : \"12312321312\", \"anchor\" : \"12312321312-4\", \"level\" : { \"$numberInt\" : \"6\" }, \"children\" : [ ] } ] } ] } ] } ] } ] } ]"
  },
  {
    "_id": "6444fca16e214b08ec68156a",
    "categoryId": "643141bf68949c11e8ca9123",
    "commentNumber": "0",
    "createDate": "1682275177043",
    "description": "111",
    "htmlContent": "<p>11111</p>",
    "scanNumber": "6",
    "thumb": "/static/upload/2023-4-24-2-39-35-64-31c77.jpg",
    "title": "test",
    "toc": "[ ]"
  },
  {
    "_id": "64457c3f6b6a3851547fe222",
    "categoryId": "6431406e68949c11e8ca90d5",
    "commentNumber": "0",
    "createDate": "1682275391880",
    "description": "123131",
    "htmlContent": "<p>123123</p>",
    "scanNumber": "1",
    "thumb": "/static/upload/2023-4-24-2-43-9-484-ff0e7.png",
    "title": "321",
    "toc": "[ ]"
  }
]